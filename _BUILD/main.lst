GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 1


   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
   9               		.stabs	"/Users/meh/_avrProjects/LCDreIDer/51-lowerRefresh/",100,0,2,.Ltext0
  10               		.stabs	"main.c",100,0,2,.Ltext0
  11               		.text
  12               	.Ltext0:
  13               		.stabs	"gcc2_compiled.",60,0,0,0
  14               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  15               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  16               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  17               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  18               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  19               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  20               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  21               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  22               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  23               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  24               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  25               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  26               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  29               		.stabs	"projInfo.h",130,0,0,0
  30               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/inttypes.h",130,0,0,0
  31               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/stdint.h",130,0,0,0
  32               		.stabs	"int8_t:t(3,1)=(0,10)",128,0,121,0
  33               		.stabs	"uint8_t:t(3,2)=(0,11)",128,0,122,0
  34               		.stabs	"int16_t:t(3,3)=(0,1)",128,0,123,0
  35               		.stabs	"uint16_t:t(3,4)=(0,4)",128,0,124,0
  36               		.stabs	"int32_t:t(3,5)=(0,3)",128,0,125,0
  37               		.stabs	"uint32_t:t(3,6)=(0,5)",128,0,126,0
  38               		.stabs	"int64_t:t(3,7)=(0,6)",128,0,128,0
  39               		.stabs	"uint64_t:t(3,8)=(0,7)",128,0,129,0
  40               		.stabs	"intptr_t:t(3,9)=(3,3)",128,0,142,0
  41               		.stabs	"uintptr_t:t(3,10)=(3,4)",128,0,147,0
  42               		.stabs	"int_least8_t:t(3,11)=(3,1)",128,0,159,0
  43               		.stabs	"uint_least8_t:t(3,12)=(3,2)",128,0,164,0
  44               		.stabs	"int_least16_t:t(3,13)=(3,3)",128,0,169,0
  45               		.stabs	"uint_least16_t:t(3,14)=(3,4)",128,0,174,0
  46               		.stabs	"int_least32_t:t(3,15)=(3,5)",128,0,179,0
  47               		.stabs	"uint_least32_t:t(3,16)=(3,6)",128,0,184,0
  48               		.stabs	"int_least64_t:t(3,17)=(3,7)",128,0,192,0
  49               		.stabs	"uint_least64_t:t(3,18)=(3,8)",128,0,199,0
  50               		.stabs	"int_fast8_t:t(3,19)=(3,1)",128,0,213,0
  51               		.stabs	"uint_fast8_t:t(3,20)=(3,2)",128,0,218,0
  52               		.stabs	"int_fast16_t:t(3,21)=(3,3)",128,0,223,0
  53               		.stabs	"uint_fast16_t:t(3,22)=(3,4)",128,0,228,0
  54               		.stabs	"int_fast32_t:t(3,23)=(3,5)",128,0,233,0
  55               		.stabs	"uint_fast32_t:t(3,24)=(3,6)",128,0,238,0
  56               		.stabs	"int_fast64_t:t(3,25)=(3,7)",128,0,246,0
  57               		.stabs	"uint_fast64_t:t(3,26)=(3,8)",128,0,253,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 2


  58               		.stabs	"intmax_t:t(3,27)=(3,7)",128,0,273,0
  59               		.stabs	"uintmax_t:t(3,28)=(3,8)",128,0,278,0
  60               		.stabn	162,0,0,0
  61               		.stabs	"int_farptr_t:t(2,1)=(3,5)",128,0,77,0
  62               		.stabs	"uint_farptr_t:t(2,2)=(3,6)",128,0,81,0
  63               		.stabn	162,0,0,0
  64               		.stabn	162,0,0,0
  65               		.stabs	"main.h",130,0,0,0
  66               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/io.h",130,0,0,0
  67               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"_commonCode_localized/heartbeat/1.21/heartbeat.h",130,0,0,0
  72               		.stabs	"./_commonCode_localized/hfModulation/1.00/hfModulation.h",130,0,0,0
  73               		.stabs	"hfm_t:t(8,1)=(8,2)=B(8,3)=s4desiredSum:(3,3),0,16;maxPower:(3,2),16,8;power:(3,2),24,8;;",
  74               		.stabn	162,0,0,0
  75               		.stabs	"./_commonCode_localized/dmsTimer/1.13/dmsTimer.h",130,0,0,0
  76               		.stabs	"dms6sec_t:t(9,1)=(3,4)",128,0,81,0
  77               		.stabs	"dms4day_t:t(9,2)=(3,6)",128,0,83,0
  78               		.stabs	"dmsMax_t:t(9,3)=(3,6)",128,0,84,0
  79               		.stabn	162,0,0,0
  80               		.stabn	162,0,0,0
  81               		.stabn	162,0,0,0
  82               		.stabs	"_commonCode_localized/sineTable/0.99/sineTable.h",130,0,0,0
  83               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/../../../../avr/include/avr/pgmspace.h",130,0,0,0
  84               		.stabs	"/usr/local/lib/gcc/avr/4.4.5/include/stddef.h",130,0,0,0
  85               		.stabs	"size_t:t(12,1)=(0,4)",128,0,211,0
  86               		.stabn	162,0,0,0
  87               		.stabs	"prog_void:t(11,1)=(11,2)=(11,2)",128,0,217,0
  88               		.stabs	"prog_char:t(11,3)=(11,4)=@s8;r(11,4);0;255;",128,0,218,0
  89               		.stabs	"prog_uchar:t(11,5)=(11,6)=@s8;r(11,6);0;255;",128,0,219,0
  90               		.stabs	"prog_int8_t:t(11,7)=(11,8)=(0,10)",128,0,221,0
  91               		.stabs	"prog_uint8_t:t(11,9)=(11,10)=(0,11)",128,0,222,0
  92               		.stabs	"prog_int16_t:t(11,11)=(11,12)=(0,1)",128,0,223,0
  93               		.stabs	"prog_uint16_t:t(11,13)=(11,14)=(0,4)",128,0,224,0
  94               		.stabs	"prog_int32_t:t(11,15)=(11,16)=(0,3)",128,0,225,0
  95               		.stabs	"prog_uint32_t:t(11,17)=(11,18)=(0,5)",128,0,226,0
  96               		.stabs	"prog_int64_t:t(11,19)=(11,20)=(0,6)",128,0,228,0
  97               		.stabs	"prog_uint64_t:t(11,21)=(11,22)=(0,7)",128,0,229,0
  98               		.stabn	162,0,0,0
  99               		.stabs	"theta_t:t(10,1)=(3,3)",128,0,76,0
 100               		.stabs	"axis_t:t(10,2)=(3,5)",128,0,123,0
 101               		.stabn	162,0,0,0
 102               		.stabs	"usi_i2c_awaitStart:F(0,15)",36,0,801,usi_i2c_awaitStart
 103               	.global	usi_i2c_awaitStart
 104               		.type	usi_i2c_awaitStart, @function
 105               	usi_i2c_awaitStart:
 106               		.stabd	46,0,0
   1:main.c        **** #include "projInfo.h"	//Don't include in main.h 'cause that's included in other .c's?
   2:main.c        **** #include "main.h"
   3:main.c        **** 
   4:main.c        **** 
   5:main.c        **** //Need to save memory space for the Tiny45...
   6:main.c        **** // (Actually, now it fits.
   7:main.c        **** //  FADER just uses the three remaining pins to cyclicly fade three LEDs
   8:main.c        **** //  You can just ignore/disable it.)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 3


   9:main.c        **** #define FADER_ENABLED TRUE //FALSE
  10:main.c        **** 
  11:main.c        **** #if (defined(FADER_ENABLED) && FADER_ENABLED)
  12:main.c        **** #include _SINETABLE_HEADER_
  13:main.c        **** #endif
  14:main.c        **** 
  15:main.c        **** 
  16:main.c        **** //For hacking when connected in single-pix mode
  17:main.c        **** // (e.g. every-other pixel will either be black or white)
  18:main.c        **** // Just comment-them-out when the single-to-dual converter is ready...
  19:main.c        **** //#define H_RES	700L
  20:main.c        **** // Unused:
  21:main.c        **** //#define V_RES	1050
  22:main.c        **** 
  23:main.c        **** //A/O v48:
  24:main.c        **** // I tend to use SwitchResX to test values, so set those values here.
  25:main.c        **** // These are the values output by the GPU (single-pixel)
  26:main.c        **** // They'll be converted to dual-pixel values as appropriate...
  27:main.c        **** // (And apparently some of the math divides it in half then later
  28:main.c        **** //  multiplies it by 2... so best not to have odd values here)
  29:main.c        **** #define PIX_CLK_GPU	(100000000UL)
  30:main.c        **** 
  31:main.c        **** #define H_ACTIVE_GPU	(1400)		//Active pixels
  32:main.c        **** #define H_FP_GPU		(32)			//Front Porch
  33:main.c        **** #define H_WIDTH_GPU	(32)			//Sync Width
  34:main.c        **** #define H_BP_GPU		(160)			//Back Porch
  35:main.c        **** //a/o v48:
  36:main.c        **** //Oddly, 16,16,64 worked with SwitchResX, but *here* they caused a
  37:main.c        **** // horizontal shift... 120 seems to have fixed it.
  38:main.c        **** // It could be that the display was already properly-synced from a
  39:main.c        **** // different timing, then switching to the new timing allowed it to remain
  40:main.c        **** // synced. Or maybe I've got some integer-rounding in here...? I dunno.
  41:main.c        **** //a/o v51:
  42:main.c        **** // 16,16,120 seems to work, but every once in a while I see a glitch in
  43:main.c        **** // terminal (sharp contrast, I guess)
  44:main.c        **** 
  45:main.c        **** #define V_ACTIVE_GPU	(1050)		//Active Rows
  46:main.c        **** #define V_FP_GPU		(0)			//Front Porch
  47:main.c        **** #define V_WIDTH_GPU	(2)			//Sync Rows
  48:main.c        **** #define V_BP_GPU		(6)			//Back Porch
  49:main.c        **** 
  50:main.c        **** 
  51:main.c        **** 
  52:main.c        **** //If you want to have alternate-timings available, set this TRUE and enter
  53:main.c        **** //the alternate-values below.
  54:main.c        **** #define ALT_TIMING	TRUE
  55:main.c        **** 
  56:main.c        **** 
  57:main.c        **** 
  58:main.c        **** #if (defined(ALT_TIMING) && ALT_TIMING)
  59:main.c        **** // According to spwg, there's room for at least one "alternate timing"
  60:main.c        **** // This could be useful here, for saving a couple values to try-out...
  61:main.c        **** // e.g. 57Hz refresh worked perfectly, as far as I could tell, but I wanted
  62:main.c        **** // to see if I could bump that up... 60Hz looked great, until I was working
  63:main.c        **** // in Terminal (lots of contrast), and I noticed a few lines would skip...
  64:main.c        **** // Hopefully, if this works, having an alternate-timing of the
  65:main.c        **** // previously-working values will make switching back easy...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 4


  66:main.c        **** // Haven't yet figured out how I'm going to implement this...
  67:main.c        **** // Alternate-timing kinda makes sense as the reliable fall-back
  68:main.c        **** // OTOH, if the main timing is set to something non-bootable, then what?
  69:main.c        **** // (If the experimental timing is put here in ALT_TIMING, then it could be
  70:main.c        **** // tested *after* booting with reliable values... OTOH, I've *also* found
  71:main.c        **** // that (maybe) the display itself has a better time syncing if it'd
  72:main.c        **** // already synced since power-up... so switching to a new (questionable)
  73:main.c        **** // value may work after the system has booted, but may not work upon a
  74:main.c        **** // fresh boot... 
  75:main.c        **** 
  76:main.c        **** // Anyways, these are the same macro-names as above, just with _ALT.
  77:main.c        **** 
  78:main.c        **** #define PIX_CLK_GPU_ALT	(100000000UL)
  79:main.c        **** 
  80:main.c        **** //These values are for a 57Hz refresh
  81:main.c        **** #define H_ACTIVE_GPU_ALT	(1400)		//Active pixels
  82:main.c        **** #define H_FP_GPU_ALT			(32)			//Front Porch
  83:main.c        **** #define H_WIDTH_GPU_ALT		(32)			//Sync Width
  84:main.c        **** #define H_BP_GPU_ALT			(180)			//Back Porch
  85:main.c        **** 
  86:main.c        **** #define V_ACTIVE_GPU_ALT	(1050)		//Active Rows
  87:main.c        **** #define V_FP_GPU_ALT			(2)			//Front Porch
  88:main.c        **** #define V_WIDTH_GPU_ALT		(2)			//Sync Rows
  89:main.c        **** #define V_BP_GPU_ALT 		(6)			//Back Porch
  90:main.c        **** 
  91:main.c        **** //a/o v51:
  92:main.c        **** //These are values used in the actual EDID array...
  93:main.c        **** // This avoids all single-to-dual translation, etc. that makes 
  94:main.c        **** // it complicated to figure out where the NON-ALT values come from...
  95:main.c        **** // (that stuff is, again, remnants of an older time, not relevent to most
  96:main.c        **** // purposes)
  97:main.c        **** #define H_BLANKING_ALT (H_FP_GPU_ALT + H_WIDTH_GPU_ALT + H_BP_GPU_ALT)
  98:main.c        **** #define V_BLANKING_ALT (V_FP_GPU_ALT + V_WIDTH_GPU_ALT + V_BP_GPU_ALT)
  99:main.c        **** 
 100:main.c        **** #endif
 101:main.c        **** 
 102:main.c        **** 
 103:main.c        **** //Currently, neither of these values can be greater than 255
 104:main.c        **** // it should be a simple change.
 105:main.c        **** #define H_IMAGE_SIZE_MM_LTD   245L
 106:main.c        **** #define V_IMAGE_SIZE_MM_LTD	184L
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** 
 110:main.c        **** 
 111:main.c        **** 
 112:main.c        **** 
 113:main.c        **** //These are dual-pixel frequencies...
 114:main.c        **** // e.g. the single-pixel transmitter (built into the mac)
 115:main.c        **** // runs at twice this speed...
 116:main.c        **** //15MHz looks nasty on boot, but macOS handles it fine
 117:main.c        **** //20MHz Boots fine
 118:main.c        **** //85MHz (single) looks great, only slight flicker (42.5MHz dual) = 47Hz
 119:main.c        **** //SwitchResX Test at 53Hz = color inversion like the plasma...
 120:main.c        **** // bit-shifts due to unmatched cable lengths?
 121:main.c        **** // bounce due to termination placement?
 122:main.c        **** //#define PIX_CLK_OVERRIDE (42500000L)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 5


 123:main.c        **** // As Of v47: 100MHz works, 104 causes jitter... (tested in SwitchResX)
 124:main.c        **** 
 125:main.c        **** 
 126:main.c        **** //a/o v51: There've been some unusual testing in here...
 127:main.c        **** //         e.g. one of the first experiments was to use a dual-pixel
 128:main.c        **** //         display *directly* with the single-pixel GPU. Thus, the
 129:main.c        **** //         horizontal resolution, according to the computer, was 1/2 the 
 130:main.c        **** //			  physical resolution of the screen...
 131:main.c        **** //         Later, this display was connected via a single-to-dual pixel
 132:main.c        **** //         converter. At this point, the EDID information shouldn't rely in
 133:main.c        **** //         any way on the fact that the display is a dual-pixel display
 134:main.c        **** //         since it looks like a single-pixel display to the computer.
 135:main.c        **** //         But the weird math remains here.
 136:main.c        **** //         As a result of these strange tests, there's some weird stuff in
 137:main.c        **** //         here regarding H_RES and PIX_CLK_OVERRIDE, etc.
 138:main.c        **** //         I haven't yet removed it.
 139:main.c        **** // e.g. As it's currently configured...
 140:main.c        **** //      (note that _LTD is referring to my LTD121... LCD. NOT "limited")
 141:main.c        **** //      PIX_CLK = PIX_CLK_TYP_LTD*2
 142:main.c        **** //                PIX_CLK_TYP_LTD = PIX_CLK_OVERRIDE
 143:main.c        **** //                                  PIX_CLK_OVERRIDE = PIX_CLK_GPU/2
 144:main.c        **** // Thus: PIX_CLK = PIX_CLK_GPU (minus rounding error)
 145:main.c        **** //
 146:main.c        **** //      H_ACTIVE = H_PIXEL_CLOCKS_LTD*2
 147:main.c        **** //                 H_PIXEL_CLOCKS_LTD = H_ACTIVE_GPU/2
 148:main.c        **** // Thus H_ACTIVE = H_ACTIVE_GPU
 149:main.c        **** //
 150:main.c        **** // H_BLANKING = H_BLANKING_TYP_LTD*2
 151:main.c        **** //              H_BLANKING_TYP_LTD = (H_FP_GPU+H_WIDTH_GPU+H_BP_GPU)/2 
 152:main.c        **** // H_BLANKING = H_FP_GPU + H_WIDTH_GPU + H_BP_GPU
 153:main.c        **** //
 154:main.c        **** // V_ACTIVE = V_ACTIVE_GPU
 155:main.c        **** //
 156:main.c        **** // V_BLANKING = V_BLANKING_TYP
 157:main.c        **** //					 V_BLANKING_TYP = V_FP_GPU + V_WIDTH_GPU + V_BP_GPU
 158:main.c        **** //
 159:main.c        **** // THFP = THFP_LTD*2
 160:main.c        **** //        THFP_LTD = H_FP_GPU/2
 161:main.c        **** // THFP = H_FP_GPU
 162:main.c        **** //
 163:main.c        **** // THW = THW_LTD*2
 164:main.c        **** //       THW_LTD = H_WIDTH_GPU/2
 165:main.c        **** // THW = H_WIDTH_GPU
 166:main.c        **** //
 167:main.c        **** // TVFP = V_FP_GPU
 168:main.c        **** // TVW = V_WIDTH_GPU 
 169:main.c        **** 
 170:main.c        **** 
 171:main.c        **** #define PIX_CLK_OVERRIDE (PIX_CLK_GPU/2) //(50000000L)
 172:main.c        **** 
 173:main.c        **** 
 174:main.c        **** //WTF: 4196 Bytes in Text region, not complaining?!
 175:main.c        **** //  Apparently somewhere in avr-gcc/libc...?
 176:main.c        **** //  (avrdude gives error when trying to write...)
 177:main.c        **** //int test[400] = {1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8};
 178:main.c        **** /*int test(void)
 179:main.c        **** {
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 6


 180:main.c        **** 	int i;
 181:main.c        **** 	int j,k;
 182:main.c        **** 
 183:main.c        **** 	j=0;
 184:main.c        **** 
 185:main.c        **** 	for(i=0; i<85; i++)
 186:main.c        **** 	{
 187:main.c        **** 		setbit(i%8, j);
 188:main.c        **** 		for(k=0; k<254; k++)
 189:main.c        **** 			setbit((k+i)%7, j);
 190:main.c        **** 	}
 191:main.c        **** 
 192:main.c        **** 	return j;
 193:main.c        **** 
 194:main.c        **** }
 195:main.c        **** */
 196:main.c        **** 
 197:main.c        **** 
 198:main.c        **** //This is the display's pixel-clock...
 199:main.c        **** #ifndef PIX_CLK_OVERRIDE
 200:main.c        **** #error "This error is just a message to me, in case my variables aren't set as I'd expected"
 201:main.c        **** #define PIX_CLK_TYP_LTD (54000000L)
 202:main.c        **** #else
 203:main.c        **** #define PIX_CLK_TYP_LTD PIX_CLK_OVERRIDE
 204:main.c        **** #endif
 205:main.c        **** 
 206:main.c        **** //This is the display's number of active pixel-clocks
 207:main.c        **** #define H_PIXEL_CLOCKS_LTD   (H_ACTIVE_GPU/2)	//700
 208:main.c        **** // and inactive...
 209:main.c        **** #define H_BLANKING_TYP_LTD 	((H_FP_GPU+H_WIDTH_GPU+H_BP_GPU)/2)	//144
 210:main.c        **** 
 211:main.c        **** //Horiz Sync Offset (THFP)
 212:main.c        **** //#define THFP_MIN_LTD (H_FP_GPU/2)	//8
 213:main.c        **** #define THFP_LTD (H_FP_GPU/2) //(THFP_MIN_LTD*2)
 214:main.c        **** 
 215:main.c        **** //Horiz Sync Pulse-Width
 216:main.c        **** //#define THW_MIN_LTD 	(H_WIDTH_GPU/2) // 8
 217:main.c        **** #define THW_LTD  (H_WIDTH_GPU/2)//(THW_MIN_LTD*2)
 218:main.c        **** 
 219:main.c        **** #ifdef H_RES
 220:main.c        **** #error "This error is just a message to me, in case I have H_RES still defined"
 221:main.c        **** // #define H_IMAGE_SIZE_MM ((uint8_t)((H_IMAGE_SIZE_MM_LTD*H_RES)/1400L))
 222:main.c        ****  #define H_IMAGE_SIZE_MM \
 223:main.c        **** 	((uint8_t)((H_IMAGE_SIZE_MM_LTD*H_RES)/(H_ACTIVE_GPU)))
 224:main.c        ****  #define V_IMAGE_SIZE_MM	V_IMAGE_SIZE_MM_LTD
 225:main.c        **** 
 226:main.c        ****  #define PIX_CLK  (PIX_CLK_TYP_LTD)
 227:main.c        ****  #define H_ACTIVE    (H_PIXEL_CLOCKS_LTD)
 228:main.c        ****  #define H_BLANKING  (H_BLANKING_TYP_LTD)
 229:main.c        ****  #define THFP (THFP_LTD)
 230:main.c        ****  #define THW (THW_LTD)
 231:main.c        **** #else
 232:main.c        ****  #define H_IMAGE_SIZE_MM	H_IMAGE_SIZE_MM_LTD
 233:main.c        ****  #define V_IMAGE_SIZE_MM	V_IMAGE_SIZE_MM_LTD
 234:main.c        **** 
 235:main.c        ****  #define PIX_CLK  (PIX_CLK_TYP_LTD*2)
 236:main.c        ****  #define H_ACTIVE (H_PIXEL_CLOCKS_LTD*2)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 7


 237:main.c        ****  #define H_BLANKING  (H_BLANKING_TYP_LTD*2)
 238:main.c        ****  #define THFP (THFP_LTD*2)
 239:main.c        ****  #define THW (THW_LTD*2)
 240:main.c        **** #endif
 241:main.c        **** 
 242:main.c        **** 
 243:main.c        **** 
 244:main.c        **** 
 245:main.c        **** 
 246:main.c        **** 
 247:main.c        **** 
 248:main.c        **** 
 249:main.c        **** 
 250:main.c        **** 
 251:main.c        **** #if !defined(__AVR_ARCH__)
 252:main.c        ****  #error "__AVR_ARCH__ not defined!"
 253:main.c        **** #endif
 254:main.c        **** 
 255:main.c        **** //#include <string.h> //for strcmp
 256:main.c        **** 
 257:main.c        **** // WTF I left this as 15 bytes but wrote 256 via usbTinyI2c 
 258:main.c        **** // and had no errors (in version 20)?!
 259:main.c        **** //uint8_t edidArray[15]; 
 260:main.c        **** // = {0x00,0xe1,0xd2,0xc3,0xb4,0xa5,0x96,0x87,8,9};
 261:main.c        **** 
 262:main.c        **** 
 263:main.c        **** 
 264:main.c        **** 
 265:main.c        **** 
 266:main.c        **** //R,G,B
 267:main.c        **** volatile uint8_t ledState[3] = {0,0,0};
 268:main.c        **** uint8_t ledIndex = 0;
 269:main.c        **** 
 270:main.c        **** 
 271:main.c        **** #define EDIDARRAYLENGTH	128 //256
 272:main.c        **** 
 273:main.c        **** 
 274:main.c        **** //Initial values stolen (and modified) from HV121P01-101
 275:main.c        **** // Notes from SPWG spec 3.8
 276:main.c        **** uint8_t edidArray[EDIDARRAYLENGTH] =
 277:main.c        **** {
 278:main.c        **** 	//Addr	Data	//Values		Notes
 279:main.c        **** //EDID Header
 280:main.c        **** 	[0x00]=	0,		//				EDID Header
 281:main.c        **** 	[0x01]=	255,
 282:main.c        **** 	[0x02]=	255,
 283:main.c        **** 	[0x03]=	255,
 284:main.c        **** 	[0x04]=	255,
 285:main.c        **** 	[0x05]=	255,
 286:main.c        **** 	[0x06]=	255,
 287:main.c        **** 	[0x07]=	0,
 288:main.c        **** 
 289:main.c        **** //Vendor/ Product ID Stuff...
 290:main.c        **** 	//ID Manufacturer Name
 291:main.c        **** 	// SPWG: "EISA manufacture code = 3 character ID (compressed ASCII)
 292:main.c        **** 	// edidv3: "2-byte representation of the monitor's manufacturer.
 293:main.c        **** 	// 	This is the same as the EISA ID. Based on compressed ASCII,
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 8


 294:main.c        **** 	//    0001=A...11010=Z."
 295:main.c        **** 	//    Bit:    7   6   5   4   3   2   1   0
 296:main.c        **** 	//
 297:main.c        **** 	//    Byte 1: 0 | 4   3   2   1   0 | 4   3
 298:main.c        **** 	//            * |      char 1       | char 2
 299:main.c        **** 	//
 300:main.c        **** 	//    Byte 2: 2   1   0 | 4   3   2   1   0
 301:main.c        **** 	//            char 2    |      char 3
 302:main.c        **** 	//    "EISA manufacturer ID's are issued by Microsoft" YAY!
 303:main.c        **** 
 304:main.c        **** //Must be uppercase char1-3
 305:main.c        **** #define TOCOMPRESSEDASCII(char1,char2,char3) \
 306:main.c        **** 	      ((((char1)-'@')<<10) | (((char2)-'@')<<5) | ((char3)-'@'))
 307:main.c        **** #define TOCOMPRESSEDASCIIBYTE1(char1,char2,char3) \
 308:main.c        **** 	      ((TOCOMPRESSEDASCII(char1,char2,char3))>>8)
 309:main.c        **** #define TOCOMPRESSEDASCIIBYTE2(char1,char2,char3) \
 310:main.c        **** 	      ((TOCOMPRESSEDASCII(char1,char2,char3))&0xff)
 311:main.c        **** 	//[0x08]=	0x30,	//LEN			ID=LEN
 312:main.c        **** 	//[0x09]=	0xAE,	
 313:main.c        **** 	[0x08]=	TOCOMPRESSEDASCIIBYTE1('M','E','H'),
 314:main.c        **** 	[0x09]=	TOCOMPRESSEDASCIIBYTE2('M','E','H'),
 315:main.c        **** 
 316:main.c        **** 	//ID Product Code
 317:main.c        **** 	// SPWG: "Pannel Supplier Reserved - Product Code"
 318:main.c        **** 	// edidv3: "vendor-assigned product code"
 319:main.c        **** 	//[0x0A]=	0x05,	//SXGA+		SXGA+ FFS
 320:main.c        **** 	//[0x0B]=	0x40,
 321:main.c        **** 	// My first product...
 322:main.c        **** 	//  should report <0x01><PROJ_VER>
 323:main.c        **** 	//  e.g. 0x01 0x30, which is kinda like version 1.30
 324:main.c        **** 	//  yeah-no. PROJ_VER=30 is not 0x30 it's 30
 325:main.c        **** 	//
 326:main.c        **** #if ( (PROJ_VER > 99) || (MY_EDID_PRODUCT_NUM > 99) )
 327:main.c        ****  #error "TOBCD(val) doesn't work with values > 99..."
 328:main.c        ****  #error "...either Project Ver or Product Num: congrats on making it this far!"
 329:main.c        **** #endif
 330:main.c        **** 
 331:main.c        **** #warning "Using PROJ_VER as the display's product-code causes new versions"
 332:main.c        **** #warning " to no longer be compatible with SwitchResX's timings for the"
 333:main.c        **** #warning " old version... Something to contemplate..."
 334:main.c        **** 	[0x0A]=	TOBCD(PROJ_VER),
 335:main.c        **** 	[0x0B]=	TOBCD(MY_EDID_PRODUCT_NUM), //0x01,
 336:main.c        **** 
 337:main.c        **** 	//32-bit serial No.
 338:main.c        **** 	// (optional; 0 if unused)
 339:main.c        **** 	[0x0C]=	0x00,	//				(blank)
 340:main.c        **** 	[0x0D]=	0x00,
 341:main.c        **** 	[0x0E]=	0x00,
 342:main.c        **** 	[0x0F]=	0x00,
 343:main.c        **** 
 344:main.c        **** 	//Week of manufacture
 345:main.c        **** 	[0x10]=	0x00,	//				(blank)
 346:main.c        **** 	//Year of manufacture (offset from 1990)
 347:main.c        **** //	[0x11]=	16,	//2006		Manufactured in 2006
 348:main.c        **** 	[0x11]=  (COMPILE_YEAR - 1990),
 349:main.c        **** 
 350:main.c        **** //EDID Version Info "Panel ID structure version/revision"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 9


 351:main.c        **** 	//EDID Structure Ver.
 352:main.c        **** 	[0x12]=	0x01,	//				EDID Ver 1.0
 353:main.c        **** 	//EDID Revision #
 354:main.c        **** 	[0x13]=	0x03,	//				EDID Rev 0.3 -- Same for E-EDID
 355:main.c        **** 
 356:main.c        **** //Display Parameters
 357:main.c        **** 	//Video input definition:
 358:main.c        **** 	// SPWG: "Vidio I/P definition = Digital I/P (0x80)"
 359:main.c        **** 	// 0x50 deduced from 0x50 = 80, assumed reversed in HV121 LCD specs...
 360:main.c        **** 	// But, apparently 0x80 was correct, according to SPWG
 361:main.c        **** 	// According to edidv3 "Digital input requires use of the EDID structure
 362:main.c        **** 	//  version 2" which doesn't appear to be the case (edidv3 is old?)
 363:main.c        **** 	// According to E-EDID Standard (newer?):
 364:main.c        **** 	// "Compatibility with monitors and systems that require EDID 
 365:main.c        **** 	//  structure 2 is achieved by allowing EDID structure 2 to 
 366:main.c        **** 	//  be included in E-EDID as two extensions residing at fixed locations"
 367:main.c        **** 	// Looking into E-EDID for now on...
 368:main.c        **** 	// Bit 7 = 1 : Digital
 369:main.c        **** 	//   Bits 6-1: Reserved = 0
 370:main.c        ****   	//   Bit 0:    "DFP 1.x" "If set=1, Interface is signal compatible
 371:main.c        **** 	//                        with VESA DFP 1.x: TMDS CRGB, 1pix/clk,
 372:main.c        **** 	//								  up to 8bits/color MSB aligned, DE active high"
 373:main.c        **** 	//             NOT SET...
 374:main.c        **** 	//             So maybe edidv3 was right....?
 375:main.c        **** 
 376:main.c        **** 	[0x14]=	0x80, //0x50,	//	"HEX=80 DEC=50" WTF?!			-------(????)
 377:main.c        **** 
 378:main.c        **** #define H_IMAGE_SIZE_CM ((H_IMAGE_SIZE_MM+5L)/10L)
 379:main.c        **** #if (H_IMAGE_SIZE_CM > 255)
 380:main.c        ****  #error "H_IMAGE_SIZE_CM is too large!"
 381:main.c        **** #endif
 382:main.c        **** 	//Max H image size (cm rounded)
 383:main.c        **** 	[0x15]=	((uint8_t)H_IMAGE_SIZE_CM), //25,	//				25cm
 384:main.c        **** 
 385:main.c        **** 	//Max V image size (rounded)
 386:main.c        **** 	[0x16]=	18,	//				18cm
 387:main.c        **** 
 388:main.c        **** 	//Display Gamma
 389:main.c        **** 	// = (gamma * 100)-100
 390:main.c        **** 	// e.g. (2.2*100)-100=120 (SPWG)
 391:main.c        **** 	[0x17]=	120,	//0x78=2.2	Gamma curve = 2.2
 392:main.c        **** 
 393:main.c        **** 	//Feature Support
 394:main.c        **** 	// SPWG: "no DPMS, Active Off, RGB, timing BLK 1 == 0x0A"
 395:main.c        **** 	// ????
 396:main.c        **** 	// Bits 7-5: standby, suspend, active-off
 397:main.c        **** 	// Bit 4-3: Display Type (b4=0, b3=1: RGB)
 398:main.c        **** 	// Bit 2: colorspace
 399:main.c        **** 	// Bit 1: Preferred Timing Mode
 400:main.c        **** 	//        "If this bit is set to 1, the display's preferred timing mode
 401:main.c        **** 	//         is indicated in the first detailed timing block.
 402:main.c        **** 	//         NOTE: Use of the preferred timing mode is required by
 403:main.c        **** 	//         EDID Structure version 1 Revision 3 and higher."
 404:main.c        **** 	// Bit 0: 0=GTF timings not supported
 405:main.c        **** 	[0x18]=	0x0A, //234,	//0xEA		RGB display, Preferred Timing Mode
 406:main.c        **** 	
 407:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 10


 408:main.c        **** 
 409:main.c        **** //Panel Color Coordinates
 410:main.c        **** 	//Red/Green low bits (RxRy/GxGy)
 411:main.c        **** 	[0x19]=	175,	//0xAF		--- Red/Green Low Bits
 412:main.c        **** 	//Blue/White low bits (BxBy/WxWy)
 413:main.c        **** 	[0x1A]=	64,	//0x40		--- Blue/White low bits
 414:main.c        **** 
 415:main.c        **** 	// Below:
 416:main.c        **** 	//  R/G/B/Wx = 0.xxx
 417:main.c        **** 	//  R/G/B/Wy = 0.xxx
 418:main.c        **** 	[0x1B]=	0x95,	// Red x high bits 95 149 0.584 
 419:main.c        **** 						// Red (x) = 10010101 (0.584) 
 420:main.c        **** 	[0x1C]=	0x56,	// Red y high bits 56 86 0.338 
 421:main.c        **** 						// Red (y) = 01010110 (0.338) 
 422:main.c        **** 	[0x1D]=	0x4A,	// Green x high bits 4A 74 0.292 
 423:main.c        **** 						// Green (x) = 01001010 (0.292) 
 424:main.c        **** 	[0x1E]=	0x8F,	// Green y high bits 8F 143 0.562 
 425:main.c        **** 						// Green (y) = 10001111 (0.562) 
 426:main.c        **** 	[0x1F]=	0x25,	// Blue x high bits 25 37 0.146 
 427:main.c        **** 						// Blue (x) = 00100101 (0.146) 
 428:main.c        **** 	[0x20]=	0x20,	// BLue y high bits 20 32 0.125 
 429:main.c        **** 						// Blue (y) = 00100000 (0.125) 
 430:main.c        **** 	[0x21]=	0x50,	// White x high bits 50 80 0.313 
 431:main.c        **** 						// White (x) = 01010000 (0.313) 
 432:main.c        **** 	[0x22]=	0x54,	// White y high bits 54 84 0.329 
 433:main.c        **** 						// White (y) = 01010100 (0.329) 
 434:main.c        **** 
 435:main.c        **** 
 436:main.c        **** //Established Timings
 437:main.c        **** 	// SPWG suggests 0x00 for all three: "not used"
 438:main.c        **** 	// "Also, if any one-bit flag is not set in the Established Timing 
 439:main.c        **** 	//  block, this data can not be used to determine if that timing is
 440:main.c        ****   	//  within the supported scanning frequency of the display - 
 441:main.c        **** 	//  only that it is not a Factory Supported Mode."
 442:main.c        **** 	// "Factory Supported Modes are defined as modes that are properly 
 443:main.c        **** 	//  sized and centered as the monitor is delivered from factory."
 444:main.c        **** 	// IOW: 0's is fine.
 445:main.c        **** 	//Established Timings I
 446:main.c        **** 	[0x23]=	0x00, //0x21,	// Established timing 1 21 33 ----
 447:main.c        **** 						// Bit 5: 640x480 @ 60Hz
 448:main.c        **** 						// Bit 0: 800x600 @ 60Hz
 449:main.c        **** 	//Established Timings II
 450:main.c        **** 	[0x24]=	0x00, //0x08,	// Established timing 2 08 8 ----
 451:main.c        **** 						// Bit 3: 1024x768 @ 60Hz
 452:main.c        **** 	//Established Timings III / Manufacturer's Timings
 453:main.c        **** 	// "Bits 6 → 0 (inclusive) of byte 3 are used to define manufacturer’s
 454:main.c        ****   	//  proprietary timings, and may be used if a manufacturer wants to 
 455:main.c        **** 	//  identify such timings through the use of one-bit flags."
 456:main.c        **** 	// NOT required, and not recommended.
 457:main.c        **** 	[0x25]=	0x00,	// Established timing 3 00 0 ----
 458:main.c        **** 
 459:main.c        **** //Standard Timing ID (SPWG suggests all = 0x01: "not used"
 460:main.c        **** 	//Standard Timing #1
 461:main.c        **** 	// These values don't make any sense! (from HV121 spec)
 462:main.c        **** 	// iBook LTN display lists none
 463:main.c        **** 	//[0x26]=	0x81,	// 81 129    HV121:"Not Used"
 464:main.c        **** 	//[0x27]=	0x80,	// 80 128 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 11


 465:main.c        **** 	[0x26 ... 0x27]= 0x01, //Not Used
 466:main.c        **** 
 467:main.c        **** 	//Standard Timings #2-8 "Not Used"
 468:main.c        **** 	// (Each is a pair of bytes, as Timing #1 above)
 469:main.c        **** 	[0x28 ... 0x35]=	0x01,	// 01 1 
 470:main.c        **** 
 471:main.c        **** //Detailed Timing/Monitor Descriptor #1 (60Hz)
 472:main.c        **** //"The first descriptor block shall be used to indicate the display's 
 473:main.c        **** // preferred timing mode"
 474:main.c        **** 	// SPWG: Pixel Clock / 10,000
 475:main.c        **** 	//[0x36]=	0x20,	// LSB 84.80 MHz Main Clock
 476:main.c        **** 	//[0x37]=	0x21,	// MSB
 477:main.c        **** 	//LTD121: 51-57MHz 54typ
 478:main.c        **** 	// WORKING WITH IT DIRECTLY HERE...
 479:main.c        **** 	// (dual-pixel mode, with second pixel blank)
 480:main.c        **** 
 481:main.c        **** 	//This is per EDID standard:
 482:main.c        ****   #define CLK_SCALE   (10000L)
 483:main.c        **** 
 484:main.c        **** 	[0x36]=	((PIX_CLK/CLK_SCALE)&0xff),
 485:main.c        **** 	[0x37]=	((PIX_CLK/CLK_SCALE)>>8),
 486:main.c        **** 	// Horizontal
 487:main.c        **** 	//0x578 = 1400, 0x0C8 = 200
 488:main.c        **** 	// SPWG Note 2:
 489:main.c        **** 	// "HA, byte 38h, is true active pixels"
 490:main.c        **** 	// "HA_pixClks, bytes 55/56, is HA for XGA 
 491:main.c        **** 	//  and HA/2 for WSXGA+ and above resolutions" this seems to be in error
 492:main.c        **** 	//[0x38]=	0x78, //120, //0x78	Hor Active = 1400 lower 8bits
 493:main.c        **** 	//[0x39]=	0xC8, //200, //0xC8	Hor Blanking = 200 lower 8bits (Thbp)
 494:main.c        **** 	//[0x3A]=	((0x05<<4) | (0x00)),	//0x50 80
 495:main.c        **** 
 496:main.c        **** 	//4bits Hor Active + 4bits Hor Blanking upper4:4bits
 497:main.c        **** 	// In pixel-clocks
 498:main.c        **** 	[0x38]=	((H_ACTIVE)&0xff),
 499:main.c        **** 	[0x39]=	((H_BLANKING)&0xff),
 500:main.c        **** 	[0x3A]=	(((H_ACTIVE)&0xf00)>>4) | (((H_BLANKING)&0xf00)>>8),
 501:main.c        **** 
 502:main.c        **** 
 503:main.c        **** //#warning "LTD-DIRECT"
 504:main.c        **** // In lines
 505:main.c        **** #define V_ACTIVE		(V_ACTIVE_GPU) //1050
 506:main.c        **** #define V_BLANKING_TYP	(V_FP_GPU+V_WIDTH_GPU+V_BP_GPU) //16
 507:main.c        **** #define V_BLANKING (V_BLANKING_TYP)
 508:main.c        **** 	// Vertical
 509:main.c        **** 	//0x41A = 1050, 0x00A = 10
 510:main.c        **** 	//[0x3B]=	0x1A,	//26	Ver Active = 1050
 511:main.c        **** 	//[0x3C]=	0x0A, //10	Ver Blanking = 10 (Tvbp)
 512:main.c        **** 						// SPWG: "DE Blanking typ. For DE only panels" ???
 513:main.c        **** 	//[0x3D]=	((0x04<<4) | (0x00)),	//0x40 64
 514:main.c        **** 						//4bits Ver Active + 4bits Ver Blanking
 515:main.c        **** 	[0x3B]=  ((V_ACTIVE)&0xff),
 516:main.c        **** 	[0x3C]=  ((V_BLANKING)&0xff),
 517:main.c        **** 	[0x3D]=  (((V_ACTIVE)&0xf00)>>4) | (((V_BLANKING)&0xf00)>>8),
 518:main.c        **** 
 519:main.c        **** 
 520:main.c        **** 	//[0x3E]=	20,	//Hor Sync Offset = 20 pixels (Thfp)
 521:main.c        **** 						//"Pixels, from blanking starts, lower 8 bits"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 12


 522:main.c        **** 	[0x3E]= ((THFP)&0xff),
 523:main.c        **** 
 524:main.c        **** 	//[0x3F]=	116,	//Hor Sync Pulse Width = 116 pixels
 525:main.c        **** 	[0x3F]= ((THW)&0xff),
 526:main.c        **** 
 527:main.c        **** 	//Vertical Sync Offset (TVFP)
 528:main.c        **** //#define TVFP_MIN	(V_FP_GPU) //0
 529:main.c        **** #define TVFP	(V_FP_GPU) //(TVFP_MIN + 2)
 530:main.c        **** 	//Vertical Sync Pulse Width
 531:main.c        **** //#define TVW_MIN	(V_WIDTH_GPU) //2
 532:main.c        **** #define TVW	(V_WIDTH_GPU) //(TVW_MIN*2)
 533:main.c        **** 	// HV121 spec seems to be misleading... should be (?)
 534:main.c        **** 	// [0x40]=((Voff&0x0f)<<4) | (Vpw&0x0f)
 535:main.c        **** 	// [0x41]=((Voff&0x30)<<6) | ((Vpw&0x30)<<4) 
 536:main.c        **** 	//        | (Hpw&0x300)>>6) | ((Hoff&0x300)>>8) --ish
 537:main.c        **** //	[0x40]=	37,	//0x25	2	Vert Sync Offset = 2 lines  ??? (Tvfp)
 538:main.c        **** 						//SPWG: "Offset=xx lines    Sync Width=xx lines"
 539:main.c        **** 	[0x40]=	(((TVFP)&0x0f)<<4) | ((TVW)&0x0f),
 540:main.c        **** 
 541:main.c        **** //	[0x41]=	0,		//0x00	5	Vert Sync Pulse Width = 5 lines
 542:main.c        **** 						//SPWG: "Horiz Vert Sync Offset/Width upper 2 bits"
 543:main.c        **** 
 544:main.c        **** #if( ((THFP)&0xffffff00) | ((THW)&0xffffff00) \
 545:main.c        **** 		| ((TVFP)&0xfffffff0) | ((TVW)&0xfffffff0) )
 546:main.c        **** 	#error "Byte 0x41 (HSYNC/VSYNC Offset/Pulsewidth upper bits NYI"
 547:main.c        **** #endif
 548:main.c        **** 
 549:main.c        **** 	[0x41]=	0,
 550:main.c        **** 
 551:main.c        **** #if (H_IMAGE_SIZE_MM > 0xff)
 552:main.c        **** 	#error "LCDreIDer doesn't yet parse H_IMAGE_SIZE_MM > 255"
 553:main.c        **** 	#error "It should be a simple modification..."
 554:main.c        **** #else
 555:main.c        **** 	#define H_IMAGE_SIZE_MM_LOWBYTE	H_IMAGE_SIZE_MM
 556:main.c        **** #endif
 557:main.c        **** 
 558:main.c        **** #if (V_IMAGE_SIZE_MM > 0xff)
 559:main.c        **** 	#error "LCDreIDer doesn't yet parse V_IMAGE_SIZE_MM > 255"
 560:main.c        **** 	#error "It should be a simple modification..."
 561:main.c        **** #else
 562:main.c        **** 	#define V_IMAGE_SIZE_MM_LOWBYTE	V_IMAGE_SIZE_MM
 563:main.c        **** #endif
 564:main.c        **** 
 565:main.c        **** 
 566:main.c        **** 	[0x42]=	H_IMAGE_SIZE_MM_LOWBYTE,
 567:main.c        **** 	[0x43]=	V_IMAGE_SIZE_MM_LOWBYTE,
 568:main.c        **** 		//0xB8,	//Vertical Image Size = 184mm (low 8 bits)
 569:main.c        **** 	[0x44]=	0x00,	// 4 bits of Hor Image Size + 4 bits of Ver Image Size
 570:main.c        **** 	[0x45]=	0x00,	//Horizontal Border = 0 pixels
 571:main.c        **** 	[0x46]=	0x00,	//Vertical Border = 0 lines
 572:main.c        **** 
 573:main.c        **** 	//Flags (bits 6,5,4,3 repurpose other bits! Don't change)
 574:main.c        **** 	// Bit7:		0=Non-Interlaced
 575:main.c        **** 	// Bit6,5:	00=non-stereo
 576:main.c        **** 	// Bit4,3:	11=Digital Separate (as opposed to composite)
 577:main.c        **** 	// Bit2:		Vertical Polarity: 1=Vsync is positive
 578:main.c        **** 	// Bit1:		Horizontal Polarity: 1=Hsync is positive
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 13


 579:main.c        **** 	// Bit0:		x (don't care, when non-stereo) E-EDID WTF See below, SPWG:
 580:main.c        **** 	//[0x47]=	0x19,	// ----- ????
 581:main.c        **** 						// SPWG: "Non-interlaced, Normal, no stereo, Separate
 582:main.c        **** 						//        sync, H/V pol Negatives" = 18
 583:main.c        **** 						//       "DE only note: LSB is set to '1' if panel is
 584:main.c        **** 						//        DE-timing only. H/V can be ignored" = 19
 585:main.c        **** 						// Indeed: HV121 specs seem to be DE-only
 586:main.c        **** 						//        "Features: Data enable signal mode"
 587:main.c        **** 						//        Also, timing diagrams do not show H/V
 588:main.c        **** 	[0x47]=	0x18,
 589:main.c        **** 
 590:main.c        **** 
 591:main.c        **** //E-EDID:
 592:main.c        **** //Notes regarding EDID Monitor Range Limits Descriptor:
 593:main.c        **** //		Use of this descriptor is mandatory. 
 594:main.c        **** //		Any timing outside these limits may cause the monitor to enter a 
 595:main.c        **** //		self-protection mode. The host shall always verify that an intended 
 596:main.c        **** //		timing falls within these limits before the timing is applied.
 597:main.c        **** // My Notes:
 598:main.c        **** //  This does not seem to be implemented in any of the displays 
 599:main.c        **** //  I've checked.
 600:main.c        **** //  Nor is it mentioned in SPWG
 601:main.c        **** //But E-EDID mentions it twice!
 602:main.c        **** // 1) All blocks shall be filled with valid data using the formats
 603:main.c        **** //		described in sections 3.10.2 and 3.10.3.  Use of a data 
 604:main.c        **** //		fill pattern is not permitted. 
 605:main.c        **** // 2) Timing data must represent a supported mode of the display. 
 606:main.c        **** //	3) Descriptor blocks shall be ordered such that all detailed timing
 607:main.c        **** //		blocks precede other  types of descriptor blocks 
 608:main.c        **** //	4) The first descriptor block shall be used to indicate the display's
 609:main.c        **** //		preferred timing mode.  This is described in section 3.10.1 
 610:main.c        **** //	5) A Monitor Range Limits Descriptor must be provided 
 611:main.c        **** //	6) A Monitor Name Descriptor must be provided 
 612:main.c        **** //Note:  Items 4, 5 and 6 above were permitted but not required prior to 
 613:main.c        **** //		EDID structure version 1 revision 3.  Hosts may encounter displays 
 614:main.c        **** //		using EDID version 1 revision 0-2 which do not meet all of these 
 615:main.c        **** //		requirements.
 616:main.c        **** // Yeah, but All the screens I've checked report to be EDID V1R3...
 617:main.c        **** 
 618:main.c        **** 
 619:main.c        **** 
 620:main.c        **** // Detailed timing/monitor descriptor #2 Alternative Panel Timing 
 621:main.c        **** 	// SPWG: "Timing Descriptor #2 may be used for timings other than 60Hz"
 622:main.c        **** 	// HV121: (dummy)
 623:main.c        **** 	//SPWG shows Timing Descriptor #2 as identically-formatted to #1
 624:main.c        **** 	// With the exception of the last byte...
 625:main.c        **** 	//  byte 0x59 "Module 'A' Revision = Example 00, 01, 02, 03, etc."
 626:main.c        **** 	// (isn't the info from Timing1's last byte necessary here too?!)
 627:main.c        **** #if (!defined(ALT_TIMING) || !ALT_TIMING)
 628:main.c        **** 	[0x48 ... 0x4A] = 0,
 629:main.c        **** 	[0x4B]=	0x10,	// Dummy Descriptor
 630:main.c        **** 	[0x4C ... 0x59] = 0,
 631:main.c        **** #else
 632:main.c        **** 	//These are identical to Timing Descriptor #1, bytes 0x36-0x47
 633:main.c        **** 	//with the exception of byte 0x59... (TBD)
 634:main.c        **** 	// AND timing macros are suffixed with _ALT,
 635:main.c        **** 	// e.g. PIX_CLK -> PIX_CLK_ALT
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 14


 636:main.c        **** 
 637:main.c        **** 	[0x48]=	((PIX_CLK_GPU_ALT/CLK_SCALE)&0xff),
 638:main.c        **** 	[0x49]=	((PIX_CLK_GPU_ALT/CLK_SCALE)>>8),
 639:main.c        **** 
 640:main.c        **** 	[0x4A]=	((H_ACTIVE_GPU_ALT)&0xff),
 641:main.c        **** 	[0x4B]=	((H_BLANKING_ALT)&0xff),
 642:main.c        **** 	[0x4C]=	(((H_ACTIVE_GPU_ALT)&0xf00)>>4) | \
 643:main.c        **** 				(((H_BLANKING_ALT)&0xf00)>>8),
 644:main.c        **** 
 645:main.c        **** 	[0x4D]=  ((V_ACTIVE_GPU_ALT)&0xff),
 646:main.c        **** 	[0x4E]=  ((V_BLANKING_ALT)&0xff),
 647:main.c        **** 	[0x4F]=  (((V_ACTIVE_GPU_ALT)&0xf00)>>4) | \
 648:main.c        **** 				(((V_BLANKING_ALT)&0xf00)>>8),
 649:main.c        **** 
 650:main.c        **** 	[0x50]= ((H_FP_GPU_ALT)&0xff),
 651:main.c        **** 	[0x51]= ((H_WIDTH_GPU_ALT)&0xff),
 652:main.c        **** 	[0x52]= (((V_FP_GPU_ALT)&0x0f)<<4) | ((V_WIDTH_GPU_ALT)&0x0f),
 653:main.c        **** 
 654:main.c        **** #if(H_FP_GPU_ALT > 0xff)
 655:main.c        **** #error "H_FP_GPU_ALT > 0xff is not yet implemented"
 656:main.c        **** #endif
 657:main.c        **** #if (H_WIDTH_GPU_ALT > 0xff)
 658:main.c        **** #error "H_WIDTH_GPU_ALT > 0xff is not yet implemented"
 659:main.c        **** #endif
 660:main.c        **** #if (V_FP_GPU_ALT > 0xf)
 661:main.c        **** #error "V_FP_GPU_ALT > 0xf is not yet implemented"
 662:main.c        **** #endif
 663:main.c        **** #if (V_WIDTH_GPU_ALT > 0xf)
 664:main.c        **** #error "V_WIDTH_GPU_ALT > 0xf is not yet implemented"
 665:main.c        **** #endif
 666:main.c        **** 	[0x53]=	0, //Upper bits are not implemented
 667:main.c        **** 
 668:main.c        **** 	[0x54]=	H_IMAGE_SIZE_MM_LOWBYTE,
 669:main.c        **** 	[0x55]=	V_IMAGE_SIZE_MM_LOWBYTE,
 670:main.c        **** 		//0xB8,	//Vertical Image Size = 184mm (low 8 bits)
 671:main.c        **** 	[0x56]=	0x00,	// 4 bits of Hor Image Size + 4 bits of Ver Image Size
 672:main.c        **** 	[0x57]=	0x00,	//Horizontal Border = 0 pixels
 673:main.c        **** 	[0x58]=	0x00,	//Vertical Border = 0 lines
 674:main.c        **** 
 675:main.c        **** 
 676:main.c        **** 	//This byte is different from 0x47, according to spwg:
 677:main.c        **** 	// "Module “A” Revision =          Example: 00, 01, 02, 03, etc."
 678:main.c        **** 	// (Doesn't it need DE, polarity, etc?!)
 679:main.c        **** 	[0x59]=	0,
 680:main.c        **** #endif
 681:main.c        **** // Detailed timing/monitor descriptor #3
 682:main.c        **** 	//SPWG: Shows #3 as same-format as HV121's #4
 683:main.c        **** 	// SPWG notes placed there
 684:main.c        **** 	// SPWG apparently doesn't have a descriptor matching this one...
 685:main.c        **** 	//[0x5A ... 0x5C] = 0,	//SPWG: "Flag" (all 0)
 686:main.c        **** 	//[0x5D]=	0x0F,	//Manufacturer Specified
 687:main.c        **** 						//  SPWG: Dummy Descriptor=0xFE
 688:main.c        **** 	//[0x5E]=	0x00,	//
 689:main.c        **** 	//[0x5F]=	144,	//1440
 690:main.c        **** 	//[0x60]=	0x43,	//4:3
 691:main.c        **** 	//[0x61]=	50,	//50Hz
 692:main.c        **** 	//[0x62 ... 0x64] = 0,	//"Not Supported"
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 15


 693:main.c        **** 	//[0x65]=	19,	//190 (what?)
 694:main.c        **** 	//[0x66]=	2,		//FFS (what??)
 695:main.c        **** 	//[0x67]=	0,		//"Reserved"
 696:main.c        **** 	// BOE ???
 697:main.c        **** 	//[0x68]=	0x09,
 698:main.c        **** 	//[0x69]=	0xE5,	
 699:main.c        **** 	//[0x6A ... 0x6B] = 0,
 700:main.c        **** 
 701:main.c        **** 	//Adding another Dummy Descriptor:
 702:main.c        **** 	[0x5A ... 0x5C] = 0,
 703:main.c        **** 	[0x5D] = 0x10,
 704:main.c        **** 	[0x5E ... 0x6B] = 0,
 705:main.c        **** 
 706:main.c        **** // Detailed timing/monitor descriptor #4
 707:main.c        **** 	// Product Name Tag (ASCII)
 708:main.c        **** 	[0x6C ... 0x6E] = 0x00,	//SPWG: "Flag"
 709:main.c        **** 	[0x6F]= 0xFC,	//Let's make this a monitor-name instead of ASCII Data	
 710:main.c        **** 			//0xFE,				//SPWG: "Dummy Descriptor" NOT: FE = ASCII Data
 711:main.c        **** 	[0x70]=	0x00,				//SPWG: "Flag"
 712:main.c        **** 
 713:main.c        **** 	// Model Name: mehLTD121KM7K //HV121P01-101
 714:main.c        **** 	[0x71]=	'm', //'H',				//SPWG: PC Maker P/N 1st Character
 715:main.c        **** 	[0x72]=	'e', //'V',				//SPWG: PC Maker P/N 2nd Character
 716:main.c        **** 	[0x73]=	'h', //'1',				//SPWG: PC Maker P/N 3rd Character
 717:main.c        **** 	[0x74]=	'L', //'2',				//SPWG: PC Maker P/N 4th Character
 718:main.c        **** 	[0x75]=	'T', //'1',				//SPWG: PC Maker P/N 5th Character
 719:main.c        **** 	[0x76]=	'D', //'P',				//SPWG: LCD Supplier Revision #
 720:main.c        **** 	[0x77]=	'1', //'0',				//SPWG: Manufacturer P/N
 721:main.c        **** 	[0x78]=	'2', //'1',				//SPWG: Manufacturer P/N
 722:main.c        **** 	[0x79]=	'1', //'-',				//SPWG: Manufacturer P/N
 723:main.c        **** 	[0x7A]=	'K', //'1',				//SPWG: Manufacturer P/N
 724:main.c        **** 	[0x7B]=	'M', //'0',				//SPWG: Manufacturer P/N
 725:main.c        **** 	[0x7C]=	'7', //'1',				//SPWG: Manufacturer P/N
 726:main.c        **** 	[0x7D]=	'K', //0x0A,				//SPWG: Manufacturer P/N
 727:main.c        **** 									//SPWG: "(if <13 char, terminate with ASCII
 728:main.c        **** 									//       code 0Ah, set remaining char = 20h"
 729:main.c        **** 									// Apparently referring to ALL characters
 730:main.c        **** 									//   0x71-0x7D
 731:main.c        **** 
 732:main.c        **** 	//SPWG Timing Descriptor #4:
 733:main.c        **** 	//0x6C-6E	0x00	Flag
 734:main.c        **** 	//0x6F		0xFE	Data Type Tag
 735:main.c        **** 	//0x70		0x00	Flag
 736:main.c        **** 	//0x71-75	XX		SMBUS Value = XX nits
 737:main.c        **** 	//0x76-77	XXX	SMBUS Value = XXX nits
 738:main.c        **** 	//0x78		XXX	SMBUS Value = max nits (Typically 00h, XXX nits)
 739:main.c        **** 	//0x79		1/2	Number of LVDS channels (1 or 2)
 740:main.c        **** 	//0x7A		0/1	Panel Self Test (00-not present, 01-present)
 741:main.c        **** 	//0x7B      0Ah	(less than 13 char, so terminate)
 742:main.c        **** 	//0x7C-7D	20h	(remaining characters, terminated above)
 743:main.c        **** 
 744:main.c        **** //The End.
 745:main.c        **** 	[0x7E]=	0,		//"Extension Flag"
 746:main.c        **** 						//SPWG: "Number of optional 128 panel ID extension blocks
 747:main.c        **** 						//      to follow, Typ=0"
 748:main.c        **** 	[0x7F]=	0x75	// CHECKSUM
 749:main.c        **** 						//SPWG: "The 1-byte sum of all 128 bytes in this panel
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 16


 750:main.c        **** 						//       ID block shall = 0"
 751:main.c        **** };
 752:main.c        **** 
 753:main.c        **** 
 754:main.c        **** uint8_t edidArrayIndex = 0;
 755:main.c        **** //Called immediately by the i2c interrupts when a byte is received
 756:main.c        **** static __inline__
 757:main.c        **** void processReceivedByte(uint8_t receivedByte, uint8_t byteNum)
 758:main.c        **** 	__attribute__((__always_inline__));
 759:main.c        **** //Called immediately by the i2c interrupts when a byte is to be loaded
 760:main.c        **** // for transmission
 761:main.c        **** static __inline__
 762:main.c        **** uint8_t nextByteToTransmit(uint8_t masterACKed)
 763:main.c        **** 	__attribute__((__always_inline__));;
 764:main.c        **** 
 765:main.c        **** 
 766:main.c        **** 
 767:main.c        **** 
 768:main.c        **** #define USICNT_MASK ((1<<USICNT3)|(1<<USICNT2)|(1<<USICNT1)|(1<<USICNT0))
 769:main.c        **** // There are four basic states: 
 770:main.c        **** //    Awaiting Start Condition
 771:main.c        **** //    ACK Transmission
 772:main.c        **** //		Address
 773:main.c        **** //    Data (read/write)
 774:main.c        **** // AWAITING values are set... others are read... (helps for readability)
 775:main.c        **** #define USI_STATE_AWAITING_START		0
 776:main.c        **** #define USI_STATE_AWAITING_START_SCL 1
 777:main.c        **** #define USI_STATE_START_SCL_RECEIVED USI_STATE_AWAITING_START_SCL
 778:main.c        **** #define USI_STATE_AWAITING_ADDRESS	2
 779:main.c        **** #define USI_STATE_ADDRESS_RECEIVED 	USI_STATE_AWAITING_ADDRESS	
 780:main.c        **** #define USI_STATE_AWAITING_ACK		3
 781:main.c        **** #define USI_STATE_ACK_COMPLETE		USI_STATE_AWAITING_ACK
 782:main.c        **** #define USI_STATE_AWAITING_BYTE	   4
 783:main.c        **** #define USI_STATE_BYTE_COMPLETE		USI_STATE_AWAITING_BYTE
 784:main.c        **** 
 785:main.c        **** //uint8_t usi_i2c_deviceAddressReceived = FALSE;
 786:main.c        **** uint8_t usi_i2c_byteToTransmit = 0xff; //0xA5;
 787:main.c        **** uint8_t usi_i2c_state = USI_STATE_AWAITING_START;
 788:main.c        **** uint8_t usi_i2c_readFromSlave = 0;
 789:main.c        **** uint8_t usi_i2c_requestedAddres = 0;
 790:main.c        **** uint8_t usi_i2c_receivedByte = 0;
 791:main.c        **** 
 792:main.c        **** #define SDA_PIN	PB0
 793:main.c        **** #define SCL_PIN	PB2
 794:main.c        **** #define SDAPORT	PORTB
 795:main.c        **** #define SCLPORT	PORTB
 796:main.c        **** 
 797:main.c        **** // This can be called in two cases:
 798:main.c        **** //   upon INIT
 799:main.c        **** //   and when a different slave has been addressed
 800:main.c        **** //      from an overflow interrupt
 801:main.c        **** void usi_i2c_awaitStart(void)
 802:main.c        **** {
 107               		.stabn	68,0,802,.LM0-.LFBB1
 108               	.LM0:
 109               	.LFBB1:
 110               	/* prologue: function */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 17


 111               	/* frame size = 0 */
 803:main.c        **** 	usi_i2c_state = USI_STATE_AWAITING_START;
 112               		.stabn	68,0,803,.LM1-.LFBB1
 113               	.LM1:
 114 0000 1092 0000 		sts usi_i2c_state,__zero_reg__
 804:main.c        **** 
 805:main.c        ****    //Clear the interrupt flags, etc. first...
 806:main.c        **** 	// NOTE This will release SCL hold (i.e. different slave addressed)
 807:main.c        ****    USISR = (1<<USISIF) //Start Condition Interrupt Flag
 115               		.stabn	68,0,807,.LM2-.LFBB1
 116               	.LM2:
 117 0004 80EE      		ldi r24,lo8(-32)
 118 0006 8EB9      		out 46-0x20,r24
 808:main.c        ****                        //  (ONLY cleared when written 1)
 809:main.c        ****          | (1<<USIOIF) //Counter Overflow Interrupt Flag
 810:main.c        ****                        //  (ONLY cleared when written 1)
 811:main.c        ****          | (1<<USIPF)  //Stop Condition Flag (not an interrupt)
 812:main.c        ****          | (0<<USIDC)  //Data Collision Flag (Read-Only, not an interrupt)
 813:main.c        ****          | (USICNT_MASK & 0); //Clear the USI counter
 814:main.c        **** 
 815:main.c        **** 
 816:main.c        ****    //Configure the USI to look for Start-Condition
 817:main.c        ****    USICR = (1<<USISIE) //Enable the start-condition interrupt
 119               		.stabn	68,0,817,.LM3-.LFBB1
 120               	.LM3:
 121 0008 88EA      		ldi r24,lo8(-88)
 122 000a 8DB9      		out 45-0x20,r24
 818:main.c        ****          | (0<<USIOIE) //Disable the counter-overflow interrupt
 819:main.c        ****          | (1<<USIWM1) //Enable two-wire mode 
 820:main.c        **** 							  // with SCL hold during start-condition
 821:main.c        ****          | (0<<USIWM0) // without SCL hold during overflow
 822:main.c        **** 							  // will be set later
 823:main.c        ****          | (1<<USICS1) //Select external clocking
 824:main.c        ****          | (0<<USICS0) //  positive-edge
 825:main.c        ****          | (0<<USICLK) //  4-bit counter counts on both external edges
 826:main.c        ****          | (0<<USITC); // DON'T toggle the clock pin 
 827:main.c        ****                        // (this should always be 0)
 828:main.c        **** 
 829:main.c        **** 	setpinPORT(SDA_PIN, SDAPORT);
 123               		.stabn	68,0,829,.LM4-.LFBB1
 124               	.LM4:
 125 000c C09A      		sbi 56-0x20,0
 830:main.c        **** 	setpinPORT(SCL_PIN, SCLPORT);
 126               		.stabn	68,0,830,.LM5-.LFBB1
 127               	.LM5:
 128 000e C29A      		sbi 56-0x20,2
 831:main.c        **** 
 832:main.c        **** 	setinPORT(SDA_PIN, SDAPORT);
 129               		.stabn	68,0,832,.LM6-.LFBB1
 130               	.LM6:
 131 0010 B898      		cbi 55-0x20,0
 833:main.c        **** 	//Enable SCL-hold during the start-condition 
 834:main.c        **** 	setoutPORT(SCL_PIN, SCLPORT);
 132               		.stabn	68,0,834,.LM7-.LFBB1
 133               	.LM7:
 134 0012 BA9A      		sbi 55-0x20,2
 135               	/* epilogue start */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 18


 835:main.c        **** }
 136               		.stabn	68,0,835,.LM8-.LFBB1
 137               	.LM8:
 138 0014 0895      		ret
 139               		.size	usi_i2c_awaitStart, .-usi_i2c_awaitStart
 140               	.Lscope1:
 141               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 142               		.stabd	78,0,0
 143               		.stabs	"usi_i2c_awaitStartSCL:F(0,15)",36,0,848,usi_i2c_awaitStartSCL
 144               	.global	usi_i2c_awaitStartSCL
 145               		.type	usi_i2c_awaitStartSCL, @function
 146               	usi_i2c_awaitStartSCL:
 147               		.stabd	46,0,0
 836:main.c        **** 
 837:main.c        **** 
 838:main.c        **** 
 839:main.c        **** //Initialize the counter to count
 840:main.c        **** //Clear the counter-overflow flag to
 841:main.c        **** //Release SCL
 842:main.c        **** // 16 clock edges will signal 8 bits received (count=0)
 843:main.c        **** // 2 clock edges will signal ACK transmitted (count=14)
 844:main.c        **** #define USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(count) \
 845:main.c        ****    (USISR = ((1<<USIOIF) | (USICNT_MASK & (count))))
 846:main.c        **** 
 847:main.c        **** //This is called after a start-condition
 848:main.c        **** void usi_i2c_awaitStartSCL(void)
 849:main.c        **** {
 148               		.stabn	68,0,849,.LM9-.LFBB2
 149               	.LM9:
 150               	.LFBB2:
 151               	/* prologue: function */
 152               	/* frame size = 0 */
 850:main.c        **** 	usi_i2c_state = USI_STATE_AWAITING_START_SCL;
 153               		.stabn	68,0,850,.LM10-.LFBB2
 154               	.LM10:
 155 0016 81E0      		ldi r24,lo8(1)
 156 0018 8093 0000 		sts usi_i2c_state,r24
 851:main.c        **** 
 852:main.c        **** 	//Before enabling the counter-overflow interrupt
 853:main.c        **** 	// make sure the flag is clear
 854:main.c        **** 	// this will also clear the counter... watch out!
 855:main.c        **** 	USISR = (1<<USIOIF);
 157               		.stabn	68,0,855,.LM11-.LFBB2
 158               	.LM11:
 159 001c 80E4      		ldi r24,lo8(64)
 160 001e 8EB9      		out 46-0x20,r24
 856:main.c        **** 
 857:main.c        ****    //Configure the USI to look for counter-overflow (start SCL received)
 858:main.c        ****    USICR = (1<<USISIE) //Enable the start-condition interrupt
 161               		.stabn	68,0,858,.LM12-.LFBB2
 162               	.LM12:
 163 0020 88EF      		ldi r24,lo8(-8)
 164 0022 8DB9      		out 45-0x20,r24
 859:main.c        ****          | (1<<USIOIE) //Enable the counter-overflow interrupt
 860:main.c        ****                        // WE'RE READY!!!
 861:main.c        ****          | (1<<USIWM1) //Enable two-wire mode
 862:main.c        ****          | (1<<USIWM0) // with SCL hold during overflow
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 19


 863:main.c        ****          | (1<<USICS1) //Select external clocking
 864:main.c        ****          | (0<<USICS0) //  positive-edge
 865:main.c        ****          | (0<<USICLK) //  4-bit counter counts on both external edges
 866:main.c        ****          | (0<<USITC); // DON'T toggle the clock pin 
 867:main.c        ****                        // (this should always be 0)
 868:main.c        **** 
 869:main.c        **** 	//Don't clear the USISIF, SCL should be released AFTER it's received!
 870:main.c        **** 	// ONE SCL change (high to low) should be counted before we're
 871:main.c        **** 	//   before we're ready for 16 edges signalling address+r/w received
 872:main.c        **** 	//APPARENTLY the USI_START_vect ISR is called until USISIF is cleared
 873:main.c        **** 	// Unless the start-SCL occurs before the overflow interrupt is enabled
 874:main.c        **** 	//  this should have the same effect (the overflow interrupt stalls SCL)
 875:main.c        **** 	// However, if the start-SCL is too fast to detect, then we're screwed
 876:main.c        **** 	// all of, what, an interrupt-jump and a few instructions?
 877:main.c        **** 	//  Maybe revisit the zipped version (using a while loop instead of
 878:main.c        **** 	//   states)
 879:main.c        **** 	// also inline this function...
 880:main.c        **** 	USISR = (1<<USISIF) | (USICNT_MASK & 15);
 165               		.stabn	68,0,880,.LM13-.LFBB2
 166               	.LM13:
 167 0024 8FE8      		ldi r24,lo8(-113)
 168 0026 8EB9      		out 46-0x20,r24
 169               	/* epilogue start */
 881:main.c        **** 	
 882:main.c        **** //	USISR = (USICNT_MASK & 15);
 883:main.c        **** //	static uint8_t callCount = 0;
 884:main.c        **** //	if(callCount < 15)
 885:main.c        **** //		callCount++;
 886:main.c        **** //	set_heartBlink(callCount);
 887:main.c        **** }
 170               		.stabn	68,0,887,.LM14-.LFBB2
 171               	.LM14:
 172 0028 0895      		ret
 173               		.size	usi_i2c_awaitStartSCL, .-usi_i2c_awaitStartSCL
 174               	.Lscope2:
 175               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 176               		.stabd	78,0,0
 177               		.stabs	"usi_i2c_slaveInit:F(0,15)",36,0,891,usi_i2c_slaveInit
 178               	.global	usi_i2c_slaveInit
 179               		.type	usi_i2c_slaveInit, @function
 180               	usi_i2c_slaveInit:
 181               		.stabd	46,0,0
 888:main.c        **** 
 889:main.c        **** 
 890:main.c        **** 
 891:main.c        **** void usi_i2c_slaveInit(void)
 892:main.c        **** {
 182               		.stabn	68,0,892,.LM15-.LFBB3
 183               	.LM15:
 184               	.LFBB3:
 185               	/* prologue: function */
 186               	/* frame size = 0 */
 893:main.c        **** 	usi_i2c_awaitStart();
 187               		.stabn	68,0,893,.LM16-.LFBB3
 188               	.LM16:
 189 002a 00D0      		rcall usi_i2c_awaitStart
 190               	/* epilogue start */
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 20


 894:main.c        **** }
 191               		.stabn	68,0,894,.LM17-.LFBB3
 192               	.LM17:
 193 002c 0895      		ret
 194               		.size	usi_i2c_slaveInit, .-usi_i2c_slaveInit
 195               	.Lscope3:
 196               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 197               		.stabd	78,0,0
 198               		.stabs	"__vector_13:F(0,15)",36,0,898,__vector_13
 199               	.global	__vector_13
 200               		.type	__vector_13, @function
 201               	__vector_13:
 202               		.stabd	46,0,0
 895:main.c        **** 
 896:main.c        **** uint8_t heartBlinkInternal = 0;
 897:main.c        **** 
 898:main.c        **** ISR(USI_START_vect)
 899:main.c        **** {
 203               		.stabn	68,0,899,.LM18-.LFBB4
 204               	.LM18:
 205               	.LFBB4:
 206 002e 1F92      		push __zero_reg__
 207 0030 0F92      		push r0
 208 0032 0FB6      		in r0,__SREG__
 209 0034 0F92      		push r0
 210 0036 1124      		clr __zero_reg__
 211 0038 8F93      		push r24
 212               	/* prologue: Signal */
 213               	/* frame size = 0 */
 900:main.c        **** 	// The start condition interrupt occurs when SDA is pulled low
 901:main.c        **** 	//   WHEN SCL is high...
 902:main.c        **** 	// Which means that the device will count an edge when SCL goes low...
 903:main.c        **** 	//   Thus, the number of clock edges will be 17 for the first 8 bits!!!
 904:main.c        **** 	//THIS IS A HACK AND SHOULD NOT BE IMPLEMENTED:
 905:main.c        **** //	while(getpinPORT(SCL_PIN, SCLPORT))
 906:main.c        **** //	{};
 907:main.c        **** 	// Should be fixed now, with the new AWAITING_START_SCL state
 908:main.c        **** 
 909:main.c        **** 	heartBlinkInternal++;
 214               		.stabn	68,0,909,.LM19-.LFBB4
 215               	.LM19:
 216 003a 8091 0000 		lds r24,heartBlinkInternal
 217 003e 8F5F      		subi r24,lo8(-(1))
 218 0040 8093 0000 		sts heartBlinkInternal,r24
 910:main.c        **** 	//set_heartBlink(heartBlinkInternal);
 911:main.c        **** 
 912:main.c        **** 	//A Start-Detection has occurred
 913:main.c        **** 	// The slaves (including this device) have pulled SCL low
 914:main.c        **** 	// (from the manual):
 915:main.c        **** 	//  The start detector will hold the SCL line low after the master has
 916:main.c        **** 	//  forced a negative edge on this line. This allows the slave to wake
 917:main.c        **** 	//  up from sleep or complete other tasks before setting up the USI 
 918:main.c        **** 	//  Data Register to receive the address. This is done by clearing the 
 919:main.c        **** 	//  start condition flag and resetting the counter. 
 920:main.c        **** 
 921:main.c        **** 	//NOT CERTAIN this is necessary
 922:main.c        **** 	// Shouldn't be, since the pin is set as an input...
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 21


 923:main.c        **** 	//   unless a START is received in the middle of a slave-write???
 924:main.c        **** 	// From the diagram showing the connections of the shift-registers
 925:main.c        **** 	// it seems we need this to prevent data collision
 926:main.c        **** 	//setinPORT(SDA_PIN, SDAPORT);
 927:main.c        **** 	//USIDR = 0xff;	
 928:main.c        **** 
 929:main.c        **** 	//Set the pin directions...
 930:main.c        **** 	// Make sure, just in case a start-condition interrupts a slave-write...
 931:main.c        **** 	setinPORT(SDA_PIN, SDAPORT);
 219               		.stabn	68,0,931,.LM20-.LFBB4
 220               	.LM20:
 221 0044 B898      		cbi 55-0x20,0
 932:main.c        **** 	// Leave the CLOCK pin active for SCL-hold at the first overflow
 933:main.c        **** 	// (once we've received address/direction)
 934:main.c        **** 	setoutPORT(SCL_PIN, SDAPORT);
 222               		.stabn	68,0,934,.LM21-.LFBB4
 223               	.LM21:
 224 0046 BA9A      		sbi 55-0x20,2
 225               	.LBB14:
 226               	.LBB15:
 850:main.c        **** 	usi_i2c_state = USI_STATE_AWAITING_START_SCL;
 227               		.stabn	68,0,850,.LM22-.LFBB4
 228               	.LM22:
 229 0048 81E0      		ldi r24,lo8(1)
 230 004a 8093 0000 		sts usi_i2c_state,r24
 855:main.c        **** 	USISR = (1<<USIOIF);
 231               		.stabn	68,0,855,.LM23-.LFBB4
 232               	.LM23:
 233 004e 80E4      		ldi r24,lo8(64)
 234 0050 8EB9      		out 46-0x20,r24
 858:main.c        ****    USICR = (1<<USISIE) //Enable the start-condition interrupt
 235               		.stabn	68,0,858,.LM24-.LFBB4
 236               	.LM24:
 237 0052 88EF      		ldi r24,lo8(-8)
 238 0054 8DB9      		out 45-0x20,r24
 880:main.c        **** 	USISR = (1<<USISIF) | (USICNT_MASK & 15);
 239               		.stabn	68,0,880,.LM25-.LFBB4
 240               	.LM25:
 241 0056 8FE8      		ldi r24,lo8(-113)
 242 0058 8EB9      		out 46-0x20,r24
 243               	/* epilogue start */
 244               	.LBE15:
 245               	.LBE14:
 935:main.c        **** 
 936:main.c        **** 	//Indicate that the address hasn't yet been received
 937:main.c        **** 	// (it should be the first byte transmitted)
 938:main.c        **** 	usi_i2c_awaitStartSCL();
 939:main.c        **** 
 940:main.c        **** 	//heartClear();
 941:main.c        **** }
 246               		.stabn	68,0,941,.LM26-.LFBB4
 247               	.LM26:
 248 005a 8F91      		pop r24
 249 005c 0F90      		pop r0
 250 005e 0FBE      		out __SREG__,r0
 251 0060 0F90      		pop r0
 252 0062 1F90      		pop __zero_reg__
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 22


 253 0064 1895      		reti
 254               		.size	__vector_13, .-__vector_13
 255               	.Lscope4:
 256               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 257               		.stabd	78,0,0
 258               		.stabs	"edid_checkSummer:F(0,15)",36,0,1248,edid_checkSummer
 259               	.global	edid_checkSummer
 260               		.type	edid_checkSummer, @function
 261               	edid_checkSummer:
 262               		.stabd	46,0,0
 942:main.c        **** 
 943:main.c        **** //shifted right once to account for R/W bit...
 944:main.c        **** #define USI_I2C_MYEDIDADDRESS 0x50
 945:main.c        **** #define USI_I2C_MYLEDADDRESS	0x60
 946:main.c        **** 
 947:main.c        **** #define usi_i2c_isMyAddress(addr) \
 948:main.c        **** 	( ((addr) == USI_I2C_MYEDIDADDRESS)\
 949:main.c        **** 	| ((addr) == USI_I2C_MYLEDADDRESS) )
 950:main.c        **** 
 951:main.c        **** 
 952:main.c        **** // In case this device handles multiple addresses... (NYI)
 953:main.c        **** uint8_t usi_i2c_requestedAddress = 0;
 954:main.c        **** 
 955:main.c        **** uint8_t byteNum = 0;
 956:main.c        **** 
 957:main.c        **** //Basically, everything after the start-condition
 958:main.c        **** // ACK and bytes...
 959:main.c        **** ISR(USI_OVF_vect)
 960:main.c        **** {
 961:main.c        **** 	//The USI counter has overflowed... this occurs in a couple cases..
 962:main.c        **** 	// First: After the address and r/w bit have been received
 963:main.c        **** 	// Second: After the ACK bit has been transmitted (by the slave)
 964:main.c        **** 	// Third: After the first data-byte has been received
 965:main.c        **** 	// Fourth: After the ACK bit has been transmitted for it...
 966:main.c        **** 	// and so on...
 967:main.c        **** 
 968:main.c        **** 	//The counter-overflow also pulls SCL Low (from the manual):
 969:main.c        **** 	// After eight bits containing slave address and data direction 
 970:main.c        **** 	// (read or write) have been transferred, the slave counter overflows 
 971:main.c        **** 	// and the SCL line is forced low. 
 972:main.c        **** 
 973:main.c        **** 	// If the slave is not the one the 
 974:main.c        **** 	// master has addressed, it releases the SCL line and waits for a new 
 975:main.c        **** 	// start condition.
 976:main.c        **** 
 977:main.c        **** 
 978:main.c        **** 	//These cases are the same as AWAITING, except if we're here,
 979:main.c        **** 	// then we're no longer awaiting them...
 980:main.c        **** 	switch(usi_i2c_state)
 981:main.c        **** 	{
 982:main.c        **** 		// The start condition interrupt occurs immediately when SDA goes low
 983:main.c        **** 		//  while SCL is high. The SCL line needs to go low once before
 984:main.c        **** 		//  data can be transmitted (this was a BITCH to find)
 985:main.c        **** 		//  in other words, there are 17 clock edges between the start-
 986:main.c        **** 		//  condition and having fully received the r/w bit
 987:main.c        **** 		case USI_STATE_START_SCL_RECEIVED:
 988:main.c        **** 	//		usi_i2c_awaitAddress();
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 23


 989:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_ADDRESS;
 990:main.c        **** 
 991:main.c        **** 		   //Clear the Start-Condition flag to release SCL
 992:main.c        **** 			// ALSO the Overflow flag for the same reason
 993:main.c        **** 			// ALSO: set the counter
 994:main.c        **** 			//   16 clock edges will signal 8 bits received (address+r/w)
 995:main.c        **** 			USISR = (1<<USISIF) //Start Condition Interrupt Flag
 996:main.c        **** 										//  (ONLY cleared when written 1)
 997:main.c        **** 					| (1<<USIOIF)	//Overflow flag 
 998:main.c        **** 		         | (USICNT_MASK & 0); //Clear the USI counter
 999:main.c        **** 
1000:main.c        **** 			break;
1001:main.c        **** 		case USI_STATE_ADDRESS_RECEIVED:
1002:main.c        **** 			{};
1003:main.c        **** 
1004:main.c        **** 			byteNum = 0;
1005:main.c        **** 			//heartClear();
1006:main.c        **** 			//Check to see if it's ours...
1007:main.c        **** 			uint8_t udrTemp = USIDR;
1008:main.c        **** 			//1 = master-read (slave-writes to SDA)
1009:main.c        **** 			//0 = master-write (slave-reads from SDA)
1010:main.c        **** 			usi_i2c_readFromSlave = udrTemp & 0x01;
1011:main.c        **** 			usi_i2c_requestedAddress = udrTemp >> 1;
1012:main.c        **** 			
1013:main.c        **** 			//From the manual:
1014:main.c        **** 			// When the slave is addressed, it holds the SDA line low during 
1015:main.c        **** 			// the acknowledgment cycle before holding the SCL line low again
1016:main.c        **** 			if( usi_i2c_isMyAddress(usi_i2c_requestedAddress) )
1017:main.c        **** 			{
1018:main.c        **** 				// Send ACK:
1019:main.c        **** 				// This is a hack:
1020:main.c        **** 				//  We get to this point on a falling-edge
1021:main.c        **** 				//  the USIDR bit 7 is loaded 0
1022:main.c        **** 				//  then the next rising edge it changes to bit 6
1023:main.c        **** 				//  the next falling edge triggers the AWAITING_ACK case below
1024:main.c        **** 				//  which releases bit 6 from the SDA pin
1025:main.c        **** 				//  The master pulls it low again for a STOP condition
1026:main.c        **** 				// It might be wiser to just set the PORT value...
1027:main.c        **** 				//USIDR = 0x3f; 
1028:main.c        **** 				USIDR = 0x00;
1029:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
1030:main.c        **** 
1031:main.c        **** 	         usi_i2c_state = USI_STATE_AWAITING_ACK;
1032:main.c        **** 
1033:main.c        **** 	         //FTM:
1034:main.c        **** 	         // (The USI Counter Register is set to 14 before releasing SCL)
1035:main.c        **** 				USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(14);
1036:main.c        **** 			}
1037:main.c        **** 			else //Another slave was addressed
1038:main.c        **** 				usi_i2c_awaitStart();
1039:main.c        **** 
1040:main.c        **** 			break;
1041:main.c        **** 		//ACK has been transmitted from/to this device...
1042:main.c        **** 		case USI_STATE_ACK_COMPLETE:
1043:main.c        **** 			if(!usi_i2c_readFromSlave)	//slaveRead
1044:main.c        **** 			{
1045:main.c        **** 				//Release SDA from the ACK (we'll be reading...)
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 24


1046:main.c        **** 				setinPORT(SDA_PIN, SDAPORT);
1047:main.c        **** 				//Shouldn't be necessary with above, but can't hurt...
1048:main.c        **** 				//UDR = 0xff; 
1049:main.c        **** 			}
1050:main.c        **** 			else //slaveWrite
1051:main.c        **** 			{
1052:main.c        **** 				uint8_t masterACK;
1053:main.c        **** 				// First ACK will be this device's response to address+r/w
1054:main.c        **** 				// Read the master's ACK?
1055:main.c        **** 				// I guess it'd be stupid to send a read request without
1056:main.c        **** 				// actually reading a byte, but I've done it for testing...
1057:main.c        **** 				// but if that's the case, then the byteToTransmit will be 
1058:main.c        **** 				// decremented anyhow... Not sure how to handle this yet...
1059:main.c        **** 				// OTOH: if a read is requested a byte MUST be transferred
1060:main.c        **** 				// otherwise a bit-7 = 0 loaded would prevent a master-stop
1061:main.c        **** 				masterACK = !(USIDR & 0x01);
1062:main.c        **** 
1063:main.c        **** 				if(byteNum)// && !(USIDR & 0x01))
1064:main.c        **** 				{
1065:main.c        **** 					heartBlinkInternal+= 0x10;
1066:main.c        **** 					//set_heartBlink(heartBlinkInternal);
1067:main.c        **** 				}
1068:main.c        **** 
1069:main.c        **** 				//Load the byte to write to the master...
1070:main.c        **** 				//USIDR = usi_i2c_byteToTransmit;
1071:main.c        **** 
1072:main.c        **** 				//if we load the next byte and its bit7 is 0
1073:main.c        **** 				// it will hold SDA low when the master tries to 
1074:main.c        **** 				// pull it high for a stop-condition!
1075:main.c        **** 				if(masterACK)
1076:main.c        **** 					USIDR = nextByteToTransmit(masterACK);
1077:main.c        **** 				else
1078:main.c        **** 					USIDR = 0xff;
1079:main.c        **** 
1080:main.c        **** 				//Decrement IF the master sent ACK...
1081:main.c        **** 				//if(masterACK)
1082:main.c        **** 				//	usi_i2c_byteToTransmit--;
1083:main.c        **** 				
1084:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
1085:main.c        **** 			}
1086:main.c        **** 
1087:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_BYTE;
1088:main.c        **** 
1089:main.c        **** 			USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(0);
1090:main.c        **** 			//heartClear();
1091:main.c        **** 			break;
1092:main.c        **** 		case USI_STATE_BYTE_COMPLETE:  //BYTE transmitted/received
1093:main.c        **** 			byteNum++;
1094:main.c        **** 			// Get the byte (if receiving)
1095:main.c        **** 			if(!usi_i2c_readFromSlave)
1096:main.c        **** 			{
1097:main.c        **** 				processReceivedByte(USIDR, byteNum);
1098:main.c        **** 				//usi_i2c_receivedByte = USIDR;
1099:main.c        **** 				heartBlinkInternal = usi_i2c_receivedByte;
1100:main.c        **** 				//set_heartBlink(heartBlinkInternal);
1101:main.c        **** //				heartClear();
1102:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 25


1103:main.c        **** 				// Also, we need to send an ACK...
1104:main.c        **** 				USIDR = 0x3f;
1105:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
1106:main.c        **** 			}
1107:main.c        **** 			else //slaveWrite
1108:main.c        **** 			{
1109:main.c        **** 				// The master sends the ACK in this case...
1110:main.c        **** 				setinPORT(SDA_PIN, SDAPORT);
1111:main.c        **** 				USIDR = 0xff;
1112:main.c        **** //				heartClear();
1113:main.c        **** 			}
1114:main.c        **** 
1115:main.c        **** 			//Reload the counter to interrupt after the ACK
1116:main.c        **** 			USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(14);
1117:main.c        **** 
1118:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_ACK;
1119:main.c        **** 			//heartClear();
1120:main.c        ****          break;
1121:main.c        **** 		//Shouldn't get here...
1122:main.c        **** 		default:
1123:main.c        **** 			usi_i2c_state = 0x77;
1124:main.c        **** 			//set_heartBlink(0x77);
1125:main.c        **** 			break;
1126:main.c        **** 	}
1127:main.c        **** 
1128:main.c        **** 
1129:main.c        **** 	//I want it to blink if it's not yet read the EDID...
1130:main.c        **** 	if((usi_i2c_readFromSlave)
1131:main.c        **** 		 && (usi_i2c_state == 4)
1132:main.c        **** 		 && (usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS))
1133:main.c        **** 		set_heartBlink(0);
1134:main.c        **** 	//set_heartBlink((!(usi_i2c_readFromSlave)<<4) | usi_i2c_state);
1135:main.c        **** }
1136:main.c        **** 
1137:main.c        **** uint8_t ledsControlled = FALSE;
1138:main.c        **** 
1139:main.c        **** #define incrementEDIDIndex()	\
1140:main.c        **** {\
1141:main.c        **** 	edidArrayIndex++;\
1142:main.c        **** 	if(edidArrayIndex == EDIDARRAYLENGTH) \
1143:main.c        **** 		edidArrayIndex = 0; \
1144:main.c        **** }
1145:main.c        **** 
1146:main.c        **** #define setEDIDIndex(index) \
1147:main.c        **** {\
1148:main.c        **** 	edidArrayIndex = index;\
1149:main.c        **** 	edidArrayIndex%=EDIDARRAYLENGTH;\
1150:main.c        **** }
1151:main.c        **** 
1152:main.c        **** #define incrementLEDIndex() \
1153:main.c        **** {\
1154:main.c        **** 	ledIndex++;\
1155:main.c        **** 	if(ledIndex == 3)\
1156:main.c        **** 		ledIndex = 0;\
1157:main.c        **** }
1158:main.c        **** 
1159:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 26


1160:main.c        **** //Interesting I haven't run into this before...
1161:main.c        **** //	if(blah)
1162:main.c        **** //		setLEDIndex(blah);
1163:main.c        **** //	else
1164:main.c        **** //	{ blah }
1165:main.c        **** // APPARENTLY the semicolon causes the if statement to be closed (?)
1166:main.c        **** #define setLEDIndex(index) \
1167:main.c        **** {\
1168:main.c        **** 	ledIndex = index;\
1169:main.c        **** 	ledIndex %= 3;\
1170:main.c        **** }
1171:main.c        **** 
1172:main.c        **** void processReceivedByte(uint8_t receivedByte, uint8_t byteNum)
1173:main.c        **** {
1174:main.c        ****   if(usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS)
1175:main.c        ****   {
1176:main.c        **** 	if(byteNum == 1)
1177:main.c        **** 	{
1178:main.c        **** 		// Could be that the EDID request doesn't send a byte-index...?
1179:main.c        **** 		//ledsControlled = FALSE;
1180:main.c        **** 		setEDIDIndex(receivedByte);
1181:main.c        **** //		edidArrayIndex = receivedByte;
1182:main.c        **** 	}
1183:main.c        **** 	else
1184:main.c        **** 	{
1185:main.c        **** 		edidArray[edidArrayIndex] = receivedByte;
1186:main.c        **** 
1187:main.c        **** 		incrementEDIDIndex();
1188:main.c        **** 		//edidArrayIndex++;
1189:main.c        **** 		//edidArrayIndex &= 0x07;
1190:main.c        **** 	}
1191:main.c        ****   }
1192:main.c        ****   else if (usi_i2c_requestedAddress == USI_I2C_MYLEDADDRESS)
1193:main.c        ****   {
1194:main.c        **** 	
1195:main.c        **** 	ledsControlled = TRUE;
1196:main.c        **** 
1197:main.c        **** 	if(byteNum == 1)
1198:main.c        **** 	{
1199:main.c        **** 		setLEDIndex(receivedByte);
1200:main.c        **** 	}
1201:main.c        **** 	else
1202:main.c        **** 	{
1203:main.c        **** 		ledState[ledIndex] = receivedByte;
1204:main.c        **** 		incrementLEDIndex();
1205:main.c        **** 	}	
1206:main.c        ****   }
1207:main.c        **** }
1208:main.c        **** 
1209:main.c        **** uint8_t nextByteToTransmit(uint8_t masterACKed)
1210:main.c        **** {
1211:main.c        **** //	static uint8_t temp = 0;
1212:main.c        **** 
1213:main.c        **** //	return temp++;
1214:main.c        **** 
1215:main.c        ****   if(usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS)
1216:main.c        ****   {
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 27


1217:main.c        **** 	uint8_t temp = edidArray[edidArrayIndex];
1218:main.c        **** 
1219:main.c        **** 	ledsControlled = FALSE;
1220:main.c        **** 	if(masterACKed)
1221:main.c        **** 	{
1222:main.c        **** 		incrementEDIDIndex();
1223:main.c        **** //		edidArrayIndex++;
1224:main.c        **** 	}
1225:main.c        **** 
1226:main.c        **** //	edidArrayIndex &= 0x07;
1227:main.c        **** 
1228:main.c        **** 	return temp;
1229:main.c        ****   }
1230:main.c        ****   else if (usi_i2c_requestedAddress == USI_I2C_MYLEDADDRESS)
1231:main.c        ****   {
1232:main.c        **** 	uint8_t temp = ledState[ledIndex];
1233:main.c        **** 
1234:main.c        **** 	if(masterACKed)
1235:main.c        **** 	{
1236:main.c        **** 		incrementLEDIndex();
1237:main.c        **** 	}
1238:main.c        **** 
1239:main.c        **** 	return temp;
1240:main.c        ****   }
1241:main.c        **** 
1242:main.c        ****   //Should only get here if we're not address
1243:main.c        ****   // in which case we shouldn't even get here.
1244:main.c        ****   return 0xff;
1245:main.c        **** }
1246:main.c        **** 
1247:main.c        **** 
1248:main.c        **** void edid_checkSummer(void)
1249:main.c        **** {
 263               		.stabn	68,0,1249,.LM27-.LFBB5
 264               	.LM27:
 265               	.LFBB5:
 266               	/* prologue: function */
 267               	/* frame size = 0 */
 268               		.stabn	68,0,1249,.LM28-.LFBB5
 269               	.LM28:
 270 0066 E0E0      		ldi r30,lo8(edidArray)
 271 0068 F0E0      		ldi r31,hi8(edidArray)
1248:main.c        **** void edid_checkSummer(void)
 272               		.stabn	68,0,1248,.LM29-.LFBB5
 273               	.LM29:
 274 006a 80E0      		ldi r24,lo8(0)
 275               	.L10:
1250:main.c        **** 	uint8_t i;
1251:main.c        **** 	uint8_t sum = 0;
1252:main.c        **** 
1253:main.c        **** 	// Don't include the garbage checksum value...
1254:main.c        **** 	// it will be overwritten here...
1255:main.c        **** 	for(i=0; i<0x7f; i++)
1256:main.c        **** 	{
1257:main.c        **** 		sum += edidArray[i];
 276               		.stabn	68,0,1257,.LM30-.LFBB5
 277               	.LM30:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 28


 278 006c 9191      		ld r25,Z+
 279 006e 890F      		add r24,r25
1255:main.c        **** 	for(i=0; i<0x7f; i++)
 280               		.stabn	68,0,1255,.LM31-.LFBB5
 281               	.LM31:
 282 0070 90E0      		ldi r25,hi8(edidArray+127)
 283 0072 E030      		cpi r30,lo8(edidArray+127)
 284 0074 F907      		cpc r31,r25
 285 0076 01F4      		brne .L10
1258:main.c        **** 	}
1259:main.c        **** 
1260:main.c        **** 	//Load the calculated checksum
1261:main.c        **** 	edidArray[0x7f] = (uint8_t)((uint8_t)0 - (uint8_t)(sum));
 286               		.stabn	68,0,1261,.LM32-.LFBB5
 287               	.LM32:
 288 0078 8195      		neg r24
 289 007a 8093 0000 		sts edidArray+127,r24
 290               	/* epilogue start */
1262:main.c        **** }
 291               		.stabn	68,0,1262,.LM33-.LFBB5
 292               	.LM33:
 293 007e 0895      		ret
 294               		.size	edid_checkSummer, .-edid_checkSummer
 295               		.stabs	"sum:r(3,2)",64,0,1251,24
 296               		.stabn	192,0,0,.LFBB5-.LFBB5
 297               		.stabn	224,0,0,.Lscope5-.LFBB5
 298               	.Lscope5:
 299               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 300               		.stabd	78,0,0
 301               		.stabs	"updateLEDs:F(0,15)",36,0,1353,updateLEDs
 302               	.global	updateLEDs
 303               		.type	updateLEDs, @function
 304               	updateLEDs:
 305               		.stabd	46,0,0
1263:main.c        **** 
1264:main.c        **** 
1265:main.c        **** 
1266:main.c        **** 
1267:main.c        **** #if FADER_ENABLED
1268:main.c        **** //uint8_t ledsControlled = FALSE;
1269:main.c        **** 
1270:main.c        **** #define  LED_R PB4				// D4
1271:main.c        **** #define  LED_G PB3				//	D5
1272:main.c        **** #define	LED_B HEART_PINNUM   //	D2 after trace-change PB1 //NYI
1273:main.c        **** #define LED_PORT PORTB
1274:main.c        **** 
1275:main.c        **** 
1276:main.c        **** hfm_t ledHFM[3];
1277:main.c        **** 
1278:main.c        **** 
1279:main.c        **** void updateLEDs(void);
1280:main.c        **** 
1281:main.c        **** void updateLEDFader(void)
1282:main.c        **** {
1283:main.c        **** 	static uint8_t delay=0;
1284:main.c        **** 	static theta_t theta=2; //test = 2;
1285:main.c        **** 
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 29


1286:main.c        **** 	delay++;
1287:main.c        **** 	if(delay == 0xff)
1288:main.c        **** 		theta++;
1289:main.c        **** 
1290:main.c        **** 	if(theta == SINE_PI*3)
1291:main.c        **** 		theta = 0;
1292:main.c        **** 
1293:main.c        **** 
1294:main.c        **** 
1295:main.c        **** 	if(theta < SINE_2PI)
1296:main.c        **** 		ledState[0] = \
1297:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2) + (int16_t)127); 
1298:main.c        **** 
1299:main.c        **** 	if((theta > SINE_PI) && (theta < SINE_PI*3))
1300:main.c        **** 	  	ledState[1] = \
1301:main.c        **** 		 	(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_PI) 
1302:main.c        **** 				+ (int16_t)127);	  
1303:main.c        **** 
1304:main.c        **** 	if(theta > SINE_2PI)
1305:main.c        **** 		ledState[2] = \
1306:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_2PI)
1307:main.c        **** 				+ (int16_t)127);
1308:main.c        **** 	else if(theta < SINE_PI)
1309:main.c        **** 		ledState[2] = \
1310:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 + SINE_PI) 
1311:main.c        **** 				+ (int16_t)127);
1312:main.c        **** //	ledState[1] = 0x07;
1313:main.c        **** 	
1314:main.c        **** //	ledState[2] = (uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2) + (int16_t)127);
1315:main.c        **** 
1316:main.c        **** 		//(uint32_t)(sineRaw(theta - SINE_PI_2))*127/SINE_MAX + 127;
1317:main.c        **** 
1318:main.c        **** 	/*
1319:main.c        **** 	if(theta == 0xff)
1320:main.c        **** 	{
1321:main.c        **** 		theta=0;
1322:main.c        **** 		ledState[2]++; // = test; //2; //0x07; //theta;
1323:main.c        **** 	}
1324:main.c        **** */
1325:main.c        **** //	ledState[0] = 0x07; //theta;
1326:main.c        **** 
1327:main.c        **** //	if(theta >= SINE_2PI) //*3)
1328:main.c        **** //		theta -= SINE_2PI; //*3;
1329:main.c        **** 
1330:main.c        **** //	if(theta == SINE_2PI*8)
1331:main.c        **** //	{
1332:main.c        **** //		theta = 0;
1333:main.c        **** //		togglebit(7, ledState[1]);
1334:main.c        **** //	}
1335:main.c        **** 
1336:main.c        **** //	if(theta < SINE_2PI)
1337:main.c        **** //		ledState[0] = (int32_t)theta*(int32_t)255/SINE_2PI;
1338:main.c        **** //			(((int32_t)sineRaw(theta) * (int32_t)127) / 
1339:main.c        **** //						 (int32_t)SINE_MAX) + 127;
1340:main.c        **** 		//((int8_t)(sineRaw(theta - SINE_PI_2)>>8) + (int8_t)127);
1341:main.c        **** 
1342:main.c        **** /*	if((theta > SINE_PI) && (theta < SINE_PI*3))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 30


1343:main.c        **** 		ledState[1] = ((sineRaw(theta - SINE_PI_2 - SINE_PI)>>8) + 127);
1344:main.c        **** 
1345:main.c        **** 	if(theta > SINE_2PI)
1346:main.c        **** 		ledState[2] = ((sineRaw(theta - SINE_PI_2 - SINE_2PI)>>8) + 127);
1347:main.c        **** 	else if(theta < SINE_PI)
1348:main.c        **** 		ledState[2] = ((sineRaw(theta - SINE_PI_2 + SINE_PI)>>8) + 127);
1349:main.c        **** */
1350:main.c        **** 	updateLEDs();
1351:main.c        **** }
1352:main.c        **** 
1353:main.c        **** void updateLEDs(void)
1354:main.c        **** {
 306               		.stabn	68,0,1354,.LM34-.LFBB6
 307               	.LM34:
 308               	.LFBB6:
 309 0080 0F93      		push r16
 310 0082 1F93      		push r17
 311 0084 CF93      		push r28
 312 0086 DF93      		push r29
 313               	/* prologue: function */
 314               	/* frame size = 0 */
 315               		.stabn	68,0,1354,.LM35-.LFBB6
 316               	.LM35:
 317 0088 00E0      		ldi r16,lo8(0)
 318 008a 10E0      		ldi r17,hi8(0)
 319 008c C0E0      		ldi r28,lo8(0)
 320 008e D0E0      		ldi r29,hi8(0)
 321               	.L15:
1355:main.c        **** 	static uint8_t lastState[3] = {0,0,0};
1356:main.c        **** 
1357:main.c        **** 	uint8_t i;
1358:main.c        **** 	for(i=0; i<3; i++)
1359:main.c        **** 	{
1360:main.c        **** 	//	if(ledState[i] != lastState[i])
1361:main.c        **** 		{
1362:main.c        **** 		//	ledsControlled = TRUE;
1363:main.c        **** 			lastState[i] = ledState[i];
 322               		.stabn	68,0,1363,.LM36-.LFBB6
 323               	.LM36:
 324 0090 FE01      		movw r30,r28
 325 0092 E050      		subi r30,lo8(-(ledState))
 326 0094 F040      		sbci r31,hi8(-(ledState))
 327 0096 8081      		ld r24,Z
 328 0098 DE01      		movw r26,r28
 329 009a A050      		subi r26,lo8(-(lastState.1732))
 330 009c B040      		sbci r27,hi8(-(lastState.1732))
 331 009e 8C93      		st X,r24
1364:main.c        **** 			hfm_setPower(&(ledHFM[i]), ledState[i]);
 332               		.stabn	68,0,1364,.LM37-.LFBB6
 333               	.LM37:
 334 00a0 6081      		ld r22,Z
 335 00a2 C801      		movw r24,r16
 336 00a4 8050      		subi r24,lo8(-(ledHFM))
 337 00a6 9040      		sbci r25,hi8(-(ledHFM))
 338 00a8 00D0      		rcall hfm_setPower
 339 00aa 2196      		adiw r28,1
 340 00ac 0C5F      		subi r16,lo8(-(4))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 31


 341 00ae 1F4F      		sbci r17,hi8(-(4))
1358:main.c        **** 	for(i=0; i<3; i++)
 342               		.stabn	68,0,1358,.LM38-.LFBB6
 343               	.LM38:
 344 00b0 C330      		cpi r28,3
 345 00b2 D105      		cpc r29,__zero_reg__
 346 00b4 01F4      		brne .L15
1365:main.c        **** 		}
1366:main.c        **** 	}
1367:main.c        **** 	//hfm_setPower(&led_r, ledState[0]);
1368:main.c        **** 	//hfm_setPower(&led_g, ledState[1]);
1369:main.c        **** 
1370:main.c        **** 
1371:main.c        **** 	if(hfm_nextOutput(&(ledHFM[0])))
 347               		.stabn	68,0,1371,.LM39-.LFBB6
 348               	.LM39:
 349 00b6 80E0      		ldi r24,lo8(ledHFM)
 350 00b8 90E0      		ldi r25,hi8(ledHFM)
 351 00ba 00D0      		rcall hfm_nextOutput
 352 00bc 8823      		tst r24
 353 00be 01F0      		breq .L16
1372:main.c        **** 		clrpinPORT(LED_R, LED_PORT);
 354               		.stabn	68,0,1372,.LM40-.LFBB6
 355               	.LM40:
 356 00c0 C498      		cbi 56-0x20,4
 357 00c2 00C0      		rjmp .L17
 358               	.L16:
1373:main.c        **** 	else
1374:main.c        **** 		setpinPORT(LED_R, LED_PORT);
 359               		.stabn	68,0,1374,.LM41-.LFBB6
 360               	.LM41:
 361 00c4 C49A      		sbi 56-0x20,4
 362               	.L17:
1375:main.c        **** 
1376:main.c        **** 	if(hfm_nextOutput(&(ledHFM[1])))
 363               		.stabn	68,0,1376,.LM42-.LFBB6
 364               	.LM42:
 365 00c6 80E0      		ldi r24,lo8(ledHFM+4)
 366 00c8 90E0      		ldi r25,hi8(ledHFM+4)
 367 00ca 00D0      		rcall hfm_nextOutput
 368 00cc 8823      		tst r24
 369 00ce 01F0      		breq .L18
1377:main.c        **** 		clrpinPORT(LED_G, LED_PORT);
 370               		.stabn	68,0,1377,.LM43-.LFBB6
 371               	.LM43:
 372 00d0 C398      		cbi 56-0x20,3
 373 00d2 00C0      		rjmp .L19
 374               	.L18:
1378:main.c        **** 	else
1379:main.c        **** 		setpinPORT(LED_G, LED_PORT);
 375               		.stabn	68,0,1379,.LM44-.LFBB6
 376               	.LM44:
 377 00d4 C39A      		sbi 56-0x20,3
 378               	.L19:
1380:main.c        **** 
1381:main.c        **** 	if(hfm_nextOutput(&(ledHFM[2])))
 379               		.stabn	68,0,1381,.LM45-.LFBB6
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 32


 380               	.LM45:
 381 00d6 80E0      		ldi r24,lo8(ledHFM+8)
 382 00d8 90E0      		ldi r25,hi8(ledHFM+8)
 383 00da 00D0      		rcall hfm_nextOutput
 384 00dc 8823      		tst r24
 385 00de 01F0      		breq .L20
1382:main.c        **** 		clrpinPORT(LED_B, LED_PORT);
 386               		.stabn	68,0,1382,.LM46-.LFBB6
 387               	.LM46:
 388 00e0 C198      		cbi 56-0x20,1
 389 00e2 00C0      		rjmp .L22
 390               	.L20:
1383:main.c        **** 	else
1384:main.c        **** 		setpinPORT(LED_B, LED_PORT);
 391               		.stabn	68,0,1384,.LM47-.LFBB6
 392               	.LM47:
 393 00e4 C19A      		sbi 56-0x20,1
 394               	.L22:
 395               	/* epilogue start */
1385:main.c        **** 
1386:main.c        **** 	//NYI:
1387:main.c        **** 	//if(ledState[2])
1388:main.c        **** 
1389:main.c        **** //	togglepinPORT(LED_R, LED_PORT);
1390:main.c        **** //	togglepinPORT(LED_G, LED_PORT);
1391:main.c        **** }
 396               		.stabn	68,0,1391,.LM48-.LFBB6
 397               	.LM48:
 398 00e6 DF91      		pop r29
 399 00e8 CF91      		pop r28
 400 00ea 1F91      		pop r17
 401 00ec 0F91      		pop r16
 402 00ee 0895      		ret
 403               		.size	updateLEDs, .-updateLEDs
 404               		.stabs	"lastState:V(0,16)=ar(0,17)=r(0,17);0;0177777;;0;2;(3,2)",38,0,1355,lastState.1732
 405               		.stabn	192,0,0,.LFBB6-.LFBB6
 406               		.stabn	224,0,0,.Lscope6-.LFBB6
 407               	.Lscope6:
 408               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 409               		.stabd	78,0,0
 410               		.stabs	"updateLEDFader:F(0,15)",36,0,1281,updateLEDFader
 411               	.global	updateLEDFader
 412               		.type	updateLEDFader, @function
 413               	updateLEDFader:
 414               		.stabd	46,0,0
1282:main.c        **** {
 415               		.stabn	68,0,1282,.LM49-.LFBB7
 416               	.LM49:
 417               	.LFBB7:
 418               	/* prologue: function */
 419               	/* frame size = 0 */
1286:main.c        **** 	delay++;
 420               		.stabn	68,0,1286,.LM50-.LFBB7
 421               	.LM50:
 422 00f0 8091 0000 		lds r24,delay.1692
 423 00f4 8F5F      		subi r24,lo8(-(1))
 424 00f6 8093 0000 		sts delay.1692,r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 33


1287:main.c        **** 	if(delay == 0xff)
 425               		.stabn	68,0,1287,.LM51-.LFBB7
 426               	.LM51:
 427 00fa 8F3F      		cpi r24,lo8(-1)
 428 00fc 01F4      		brne .L25
1288:main.c        **** 		theta++;
 429               		.stabn	68,0,1288,.LM52-.LFBB7
 430               	.LM52:
 431 00fe 8091 0000 		lds r24,theta.1693
 432 0102 9091 0000 		lds r25,(theta.1693)+1
 433 0106 0196      		adiw r24,1
 434 0108 9093 0000 		sts (theta.1693)+1,r25
 435 010c 8093 0000 		sts theta.1693,r24
 436               	.L25:
1290:main.c        **** 	if(theta == SINE_PI*3)
 437               		.stabn	68,0,1290,.LM53-.LFBB7
 438               	.LM53:
 439 0110 8091 0000 		lds r24,theta.1693
 440 0114 9091 0000 		lds r25,(theta.1693)+1
 441 0118 23E0      		ldi r18,hi8(768)
 442 011a 8030      		cpi r24,lo8(768)
 443 011c 9207      		cpc r25,r18
 444 011e 01F4      		brne .L26
1291:main.c        **** 		theta = 0;
 445               		.stabn	68,0,1291,.LM54-.LFBB7
 446               	.LM54:
 447 0120 1092 0000 		sts (theta.1693)+1,__zero_reg__
 448 0124 1092 0000 		sts theta.1693,__zero_reg__
 449               	.L26:
1295:main.c        **** 	if(theta < SINE_2PI)
 450               		.stabn	68,0,1295,.LM55-.LFBB7
 451               	.LM55:
 452 0128 8091 0000 		lds r24,theta.1693
 453 012c 9091 0000 		lds r25,(theta.1693)+1
 454 0130 42E0      		ldi r20,hi8(512)
 455 0132 8030      		cpi r24,lo8(512)
 456 0134 9407      		cpc r25,r20
 457 0136 04F4      		brge .L27
1297:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2) + (int16_t)127); 
 458               		.stabn	68,0,1297,.LM56-.LFBB7
 459               	.LM56:
 460 0138 8058      		subi r24,lo8(-(-128))
 461 013a 9040      		sbci r25,hi8(-(-128))
 462 013c 00D0      		rcall sineRaw8
 463 013e 8158      		subi r24,lo8(-(127))
1296:main.c        **** 		ledState[0] = \
 464               		.stabn	68,0,1296,.LM57-.LFBB7
 465               	.LM57:
 466 0140 8093 0000 		sts ledState,r24
 467               	.L27:
1299:main.c        **** 	if((theta > SINE_PI) && (theta < SINE_PI*3))
 468               		.stabn	68,0,1299,.LM58-.LFBB7
 469               	.LM58:
 470 0144 8091 0000 		lds r24,theta.1693
 471 0148 9091 0000 		lds r25,(theta.1693)+1
 472 014c 9C01      		movw r18,r24
 473 014e 2150      		subi r18,lo8(-(-257))
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 34


 474 0150 3140      		sbci r19,hi8(-(-257))
 475 0152 41E0      		ldi r20,hi8(511)
 476 0154 2F3F      		cpi r18,lo8(511)
 477 0156 3407      		cpc r19,r20
 478 0158 00F4      		brsh .L28
1301:main.c        **** 		 	(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_PI) 
 479               		.stabn	68,0,1301,.LM59-.LFBB7
 480               	.LM59:
 481 015a 8058      		subi r24,lo8(-(-384))
 482 015c 9140      		sbci r25,hi8(-(-384))
 483 015e 00D0      		rcall sineRaw8
 484 0160 8158      		subi r24,lo8(-(127))
1300:main.c        **** 	  	ledState[1] = \
 485               		.stabn	68,0,1300,.LM60-.LFBB7
 486               	.LM60:
 487 0162 8093 0000 		sts ledState+1,r24
 488               	.L28:
1304:main.c        **** 	if(theta > SINE_2PI)
 489               		.stabn	68,0,1304,.LM61-.LFBB7
 490               	.LM61:
 491 0166 8091 0000 		lds r24,theta.1693
 492 016a 9091 0000 		lds r25,(theta.1693)+1
 493 016e 22E0      		ldi r18,hi8(513)
 494 0170 8130      		cpi r24,lo8(513)
 495 0172 9207      		cpc r25,r18
 496 0174 04F0      		brlt .L29
1306:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 - SINE_2PI)
 497               		.stabn	68,0,1306,.LM62-.LFBB7
 498               	.LM62:
 499 0176 8058      		subi r24,lo8(-(-640))
 500 0178 9240      		sbci r25,hi8(-(-640))
 501 017a 00C0      		rjmp .L32
 502               	.L29:
1308:main.c        **** 	else if(theta < SINE_PI)
 503               		.stabn	68,0,1308,.LM63-.LFBB7
 504               	.LM63:
 505 017c 8F3F      		cpi r24,255
 506 017e 9105      		cpc r25,__zero_reg__
 507 0180 01F0      		breq .+2
 508 0182 04F4      		brge .L30
1310:main.c        **** 			(uint8_t)((int16_t)sineRaw8(theta - SINE_PI_2 + SINE_PI) 
 509               		.stabn	68,0,1310,.LM64-.LFBB7
 510               	.LM64:
 511 0184 8058      		subi r24,lo8(-(128))
 512 0186 9F4F      		sbci r25,hi8(-(128))
 513               	.L32:
 514 0188 00D0      		rcall sineRaw8
 515 018a 8158      		subi r24,lo8(-(127))
1309:main.c        **** 		ledState[2] = \
 516               		.stabn	68,0,1309,.LM65-.LFBB7
 517               	.LM65:
 518 018c 8093 0000 		sts ledState+2,r24
 519               	.L30:
1350:main.c        **** 	updateLEDs();
 520               		.stabn	68,0,1350,.LM66-.LFBB7
 521               	.LM66:
 522 0190 00D0      		rcall updateLEDs
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 35


 523               	/* epilogue start */
1351:main.c        **** }
 524               		.stabn	68,0,1351,.LM67-.LFBB7
 525               	.LM67:
 526 0192 0895      		ret
 527               		.size	updateLEDFader, .-updateLEDFader
 528               		.stabs	"delay:V(3,2)",38,0,1283,delay.1692
 529               		.stabs	"theta:V(10,1)",38,0,1284,theta.1693
 530               		.stabn	192,0,0,.LFBB7-.LFBB7
 531               		.stabn	224,0,0,.Lscope7-.LFBB7
 532               	.Lscope7:
 533               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 534               		.stabd	78,0,0
 535               		.stabs	"main:F(0,1)",36,0,1394,main
 536               	.global	main
 537               		.type	main, @function
 538               	main:
 539               		.stabd	46,0,0
1392:main.c        **** #endif
1393:main.c        **** 
1394:main.c        **** int main(void)
1395:main.c        **** {
 540               		.stabn	68,0,1395,.LM68-.LFBB8
 541               	.LM68:
 542               	.LFBB8:
 543 0194 CF93      		push r28
 544 0196 DF93      		push r29
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               		.stabn	68,0,1395,.LM69-.LFBB8
 548               	.LM69:
 549 0198 C0E0      		ldi r28,lo8(0)
 550 019a D0E0      		ldi r29,hi8(0)
 551               	.L34:
1396:main.c        **** #if FADER_ENABLED
1397:main.c        **** 	uint8_t i;
1398:main.c        **** 	for(i=0; i<3; i++)
1399:main.c        **** 		hfm_setup(&(ledHFM[i]), 0, 255);
 552               		.stabn	68,0,1399,.LM70-.LFBB8
 553               	.LM70:
 554 019c CE01      		movw r24,r28
 555 019e 8050      		subi r24,lo8(-(ledHFM))
 556 01a0 9040      		sbci r25,hi8(-(ledHFM))
 557 01a2 60E0      		ldi r22,lo8(0)
 558 01a4 4FEF      		ldi r20,lo8(-1)
 559 01a6 00D0      		rcall hfm_setup
 560 01a8 2496      		adiw r28,4
1398:main.c        **** 	for(i=0; i<3; i++)
 561               		.stabn	68,0,1398,.LM71-.LFBB8
 562               	.LM71:
 563 01aa CC30      		cpi r28,12
 564 01ac D105      		cpc r29,__zero_reg__
 565 01ae 01F4      		brne .L34
1400:main.c        **** 	//hfm_setup(&led_g, 0, 255);
1401:main.c        **** #endif
1402:main.c        **** 
1403:main.c        **** //	uint16_t i;
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 36


1404:main.c        **** //	for(i=0; i<256; i++)
1405:main.c        **** //		edidArray[i] = i;
1406:main.c        **** 
1407:main.c        **** 	//Found experimentally: assuming the free-running ADC is always 13
1408:main.c        **** 	// cycles per interrupt...
1409:main.c        **** 	// The default value was read to be 0x9f
1410:main.c        **** 	// This is of course device-specific
1411:main.c        **** //	OSCCAL = 0x9a;
1412:main.c        **** 
1413:main.c        **** 	//*** Initializations ***
1414:main.c        **** 
1415:main.c        **** 	//!!! WDT could cause problems... this probably should be inited earlier and called everywhere...
1416:main.c        **** 	//INIT_HEARTBEAT(HEARTBEATPIN, HEARTBEAT, HEARTCONNECTION);
1417:main.c        **** 
1418:main.c        **** 
1419:main.c        **** 	init_heartBeat();
 566               		.stabn	68,0,1419,.LM72-.LFBB8
 567               	.LM72:
 568 01b0 00D0      		rcall init_heartBeat
1420:main.c        **** 
1421:main.c        **** 	setHeartRate(0);	
 569               		.stabn	68,0,1421,.LM73-.LFBB8
 570               	.LM73:
 571 01b2 80E0      		ldi r24,lo8(0)
 572 01b4 00D0      		rcall setHeartRate
1422:main.c        **** 
1423:main.c        **** 	//Blink until the EDID is read...
1424:main.c        **** 	//This is hokey...
1425:main.c        **** 	//set_heartBlink(1);
1426:main.c        **** 
1427:main.c        **** 	edid_checkSummer();
 573               		.stabn	68,0,1427,.LM74-.LFBB8
 574               	.LM74:
 575 01b6 00D0      		rcall edid_checkSummer
 576               	.LBB16:
 577               	.LBB17:
 893:main.c        **** 	usi_i2c_awaitStart();
 578               		.stabn	68,0,893,.LM75-.LFBB8
 579               	.LM75:
 580 01b8 00D0      		rcall usi_i2c_awaitStart
 581               	.LBE17:
 582               	.LBE16:
1428:main.c        **** 
1429:main.c        **** 	usi_i2c_slaveInit();
1430:main.c        **** 
1431:main.c        **** #if FADER_ENABLED
1432:main.c        **** 	setoutPORT(LED_R, LED_PORT);
 583               		.stabn	68,0,1432,.LM76-.LFBB8
 584               	.LM76:
 585 01ba BC9A      		sbi 55-0x20,4
1433:main.c        **** 	setoutPORT(LED_G, LED_PORT);
 586               		.stabn	68,0,1433,.LM77-.LFBB8
 587               	.LM77:
 588 01bc BB9A      		sbi 55-0x20,3
1434:main.c        **** 	setpinPORT(LED_R, LED_PORT);
 589               		.stabn	68,0,1434,.LM78-.LFBB8
 590               	.LM78:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 37


 591 01be C49A      		sbi 56-0x20,4
1435:main.c        **** 	setpinPORT(LED_G, LED_PORT);
 592               		.stabn	68,0,1435,.LM79-.LFBB8
 593               	.LM79:
 594 01c0 C39A      		sbi 56-0x20,3
 595               	.L40:
1436:main.c        **** #endif
1437:main.c        **** 
1438:main.c        **** //	setoutPORT(LED_B, LED_PORT);
1439:main.c        **** 
1440:main.c        **** 	//This was only necessary for debugging timer initialization bugs...
1441:main.c        **** 	// which have been resolved
1442:main.c        **** //	set_heartBlink(retVal);
1443:main.c        **** 
1444:main.c        **** 	while(1)
1445:main.c        **** 	{
1446:main.c        **** #if FADER_ENABLED
1447:main.c        **** 		if(!ledsControlled)
 596               		.stabn	68,0,1447,.LM80-.LFBB8
 597               	.LM80:
 598 01c2 8091 0000 		lds r24,ledsControlled
 599 01c6 8823      		tst r24
 600 01c8 01F4      		brne .L35
1448:main.c        **** 		{
1449:main.c        **** 			extern uint8_t heartBlink; 
1450:main.c        **** 
1451:main.c        **** 			if(heartBlink)
 601               		.stabn	68,0,1451,.LM81-.LFBB8
 602               	.LM81:
 603 01ca 8091 0000 		lds r24,heartBlink
 604 01ce 8823      		tst r24
 605 01d0 01F0      		breq .L36
1452:main.c        **** 				heartUpdate();
 606               		.stabn	68,0,1452,.LM82-.LFBB8
 607               	.LM82:
 608 01d2 00D0      		rcall heartUpdate
 609 01d4 00C0      		rjmp .L40
 610               	.L36:
1453:main.c        **** 			else
1454:main.c        **** 				updateLEDFader();
 611               		.stabn	68,0,1454,.LM83-.LFBB8
 612               	.LM83:
 613 01d6 00D0      		rcall updateLEDFader
 614 01d8 00C0      		rjmp .L40
 615               	.L35:
1455:main.c        **** 		}
1456:main.c        **** 		//This was not previously elsed... how did the heart work at all?!
1457:main.c        **** 		// at one point it didn't (and neither did updateLEDs()
1458:main.c        **** 		// but somehow it started up again
1459:main.c        **** 		// a/o v49: May have been a result of the hfm bug...
1460:main.c        **** 		// 			(how did it start up again? Something to do with an
1461:main.c        **** 		//           uninitialized value in HFM?)
1462:main.c        **** 		else
1463:main.c        **** 		{
1464:main.c        **** 			// The heartbeat may have been in input (off) mode when switched
1465:main.c        **** 			setoutPORT(LED_B, LED_PORT);
 616               		.stabn	68,0,1465,.LM84-.LFBB8
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 38


 617               	.LM84:
 618 01da B99A      		sbi 55-0x20,1
1466:main.c        **** 
1467:main.c        **** 			updateLEDs();
 619               		.stabn	68,0,1467,.LM85-.LFBB8
 620               	.LM85:
 621 01dc 00D0      		rcall updateLEDs
 622 01de 00C0      		rjmp .L40
 623               		.size	main, .-main
 624               	.Lscope8:
 625               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 626               		.stabd	78,0,0
 627               		.stabs	"__vector_14:F(0,15)",36,0,959,__vector_14
 628               	.global	__vector_14
 629               		.type	__vector_14, @function
 630               	__vector_14:
 631               		.stabd	46,0,0
 960:main.c        **** {
 632               		.stabn	68,0,960,.LM86-.LFBB9
 633               	.LM86:
 634               	.LFBB9:
 635 01e0 1F92      		push __zero_reg__
 636 01e2 0F92      		push r0
 637 01e4 0FB6      		in r0,__SREG__
 638 01e6 0F92      		push r0
 639 01e8 1124      		clr __zero_reg__
 640 01ea 2F93      		push r18
 641 01ec 3F93      		push r19
 642 01ee 4F93      		push r20
 643 01f0 5F93      		push r21
 644 01f2 6F93      		push r22
 645 01f4 7F93      		push r23
 646 01f6 8F93      		push r24
 647 01f8 9F93      		push r25
 648 01fa AF93      		push r26
 649 01fc BF93      		push r27
 650 01fe EF93      		push r30
 651 0200 FF93      		push r31
 652               	/* prologue: Signal */
 653               	/* frame size = 0 */
 980:main.c        **** 	switch(usi_i2c_state)
 654               		.stabn	68,0,980,.LM87-.LFBB9
 655               	.LM87:
 656 0202 8091 0000 		lds r24,usi_i2c_state
 657 0206 8230      		cpi r24,lo8(2)
 658 0208 01F0      		breq .L44
 659 020a 8330      		cpi r24,lo8(3)
 660 020c 00F4      		brsh .L47
 661 020e 8130      		cpi r24,lo8(1)
 662 0210 01F0      		breq .+2
 663 0212 00C0      		rjmp .L42
 664 0214 00C0      		rjmp .L73
 665               	.L47:
 666 0216 8330      		cpi r24,lo8(3)
 667 0218 01F0      		breq .L45
 668 021a 8430      		cpi r24,lo8(4)
 669 021c 01F0      		breq .+2
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 39


 670 021e 00C0      		rjmp .L42
 671 0220 00C0      		rjmp .L74
 672               	.L73:
 673               	.LBB18:
 989:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_ADDRESS;
 674               		.stabn	68,0,989,.LM88-.LFBB9
 675               	.LM88:
 676 0222 82E0      		ldi r24,lo8(2)
 677 0224 8093 0000 		sts usi_i2c_state,r24
 995:main.c        **** 			USISR = (1<<USISIF) //Start Condition Interrupt Flag
 678               		.stabn	68,0,995,.LM89-.LFBB9
 679               	.LM89:
 680 0228 80EC      		ldi r24,lo8(-64)
 681 022a 00C0      		rjmp .L69
 682               	.L44:
1004:main.c        **** 			byteNum = 0;
 683               		.stabn	68,0,1004,.LM90-.LFBB9
 684               	.LM90:
 685 022c 1092 0000 		sts byteNum,__zero_reg__
1007:main.c        **** 			uint8_t udrTemp = USIDR;
 686               		.stabn	68,0,1007,.LM91-.LFBB9
 687               	.LM91:
 688 0230 8FB1      		in r24,47-0x20
1010:main.c        **** 			usi_i2c_readFromSlave = udrTemp & 0x01;
 689               		.stabn	68,0,1010,.LM92-.LFBB9
 690               	.LM92:
 691 0232 982F      		mov r25,r24
 692 0234 9170      		andi r25,lo8(1)
 693 0236 9093 0000 		sts usi_i2c_readFromSlave,r25
1011:main.c        **** 			usi_i2c_requestedAddress = udrTemp >> 1;
 694               		.stabn	68,0,1011,.LM93-.LFBB9
 695               	.LM93:
 696 023a 8695      		lsr r24
 697 023c 8093 0000 		sts usi_i2c_requestedAddress,r24
1016:main.c        **** 			if( usi_i2c_isMyAddress(usi_i2c_requestedAddress) )
 698               		.stabn	68,0,1016,.LM94-.LFBB9
 699               	.LM94:
 700 0240 8036      		cpi r24,lo8(96)
 701 0242 01F0      		breq .L67
 702 0244 8035      		cpi r24,lo8(80)
 703 0246 01F4      		brne .L49
 704               	.L67:
1028:main.c        **** 				USIDR = 0x00;
 705               		.stabn	68,0,1028,.LM95-.LFBB9
 706               	.LM95:
 707 0248 1FB8      		out 47-0x20,__zero_reg__
1029:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
 708               		.stabn	68,0,1029,.LM96-.LFBB9
 709               	.LM96:
 710 024a B89A      		sbi 55-0x20,0
1031:main.c        **** 	         usi_i2c_state = USI_STATE_AWAITING_ACK;
 711               		.stabn	68,0,1031,.LM97-.LFBB9
 712               	.LM97:
 713 024c 83E0      		ldi r24,lo8(3)
 714 024e 8093 0000 		sts usi_i2c_state,r24
1035:main.c        **** 				USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(14);
 715               		.stabn	68,0,1035,.LM98-.LFBB9
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 40


 716               	.LM98:
 717 0252 8EE4      		ldi r24,lo8(78)
 718               	.L69:
 719 0254 8EB9      		out 46-0x20,r24
 720 0256 00C0      		rjmp .L48
 721               	.L49:
1038:main.c        **** 				usi_i2c_awaitStart();
 722               		.stabn	68,0,1038,.LM99-.LFBB9
 723               	.LM99:
 724 0258 00D0      		rcall usi_i2c_awaitStart
 725 025a 00C0      		rjmp .L48
 726               	.L45:
1043:main.c        **** 			if(!usi_i2c_readFromSlave)	//slaveRead
 727               		.stabn	68,0,1043,.LM100-.LFBB9
 728               	.LM100:
 729 025c 8091 0000 		lds r24,usi_i2c_readFromSlave
 730 0260 8823      		tst r24
 731 0262 01F4      		brne .L51
1046:main.c        **** 				setinPORT(SDA_PIN, SDAPORT);
 732               		.stabn	68,0,1046,.LM101-.LFBB9
 733               	.LM101:
 734 0264 B898      		cbi 55-0x20,0
 735 0266 00C0      		rjmp .L52
 736               	.L51:
 737               	.LBB19:
1061:main.c        **** 				masterACK = !(USIDR & 0x01);
 738               		.stabn	68,0,1061,.LM102-.LFBB9
 739               	.LM102:
 740 0268 9FB1      		in r25,47-0x20
1063:main.c        **** 				if(byteNum)// && !(USIDR & 0x01))
 741               		.stabn	68,0,1063,.LM103-.LFBB9
 742               	.LM103:
 743 026a 8091 0000 		lds r24,byteNum
 744 026e 8823      		tst r24
 745 0270 01F0      		breq .L53
1065:main.c        **** 					heartBlinkInternal+= 0x10;
 746               		.stabn	68,0,1065,.LM104-.LFBB9
 747               	.LM104:
 748 0272 8091 0000 		lds r24,heartBlinkInternal
 749 0276 805F      		subi r24,lo8(-(16))
 750 0278 8093 0000 		sts heartBlinkInternal,r24
 751               	.L53:
1075:main.c        **** 				if(masterACK)
 752               		.stabn	68,0,1075,.LM105-.LFBB9
 753               	.LM105:
 754 027c 90FD      		sbrc r25,0
 755 027e 00C0      		rjmp .L54
 756               	.LBB20:
 757               	.LBB21:
1215:main.c        ****   if(usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS)
 758               		.stabn	68,0,1215,.LM106-.LFBB9
 759               	.LM106:
 760 0280 8091 0000 		lds r24,usi_i2c_requestedAddress
 761 0284 8035      		cpi r24,lo8(80)
 762 0286 01F4      		brne .L55
 763               	.LBB22:
1217:main.c        **** 	uint8_t temp = edidArray[edidArrayIndex];
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 41


 764               		.stabn	68,0,1217,.LM107-.LFBB9
 765               	.LM107:
 766 0288 9091 0000 		lds r25,edidArrayIndex
 767 028c E92F      		mov r30,r25
 768 028e F0E0      		ldi r31,lo8(0)
 769 0290 E050      		subi r30,lo8(-(edidArray))
 770 0292 F040      		sbci r31,hi8(-(edidArray))
 771 0294 8081      		ld r24,Z
1219:main.c        **** 	ledsControlled = FALSE;
 772               		.stabn	68,0,1219,.LM108-.LFBB9
 773               	.LM108:
 774 0296 1092 0000 		sts ledsControlled,__zero_reg__
1222:main.c        **** 		incrementEDIDIndex();
 775               		.stabn	68,0,1222,.LM109-.LFBB9
 776               	.LM109:
 777 029a 9F5F      		subi r25,lo8(-(1))
 778 029c 9093 0000 		sts edidArrayIndex,r25
 779 02a0 9038      		cpi r25,lo8(-128)
 780 02a2 01F4      		brne .L68
 781 02a4 1092 0000 		sts edidArrayIndex,__zero_reg__
 782 02a8 00C0      		rjmp .L68
 783               	.L55:
 784               	.LBE22:
1230:main.c        ****   else if (usi_i2c_requestedAddress == USI_I2C_MYLEDADDRESS)
 785               		.stabn	68,0,1230,.LM110-.LFBB9
 786               	.LM110:
 787 02aa 8036      		cpi r24,lo8(96)
 788 02ac 01F4      		brne .L54
 789               	.LBB23:
1232:main.c        **** 	uint8_t temp = ledState[ledIndex];
 790               		.stabn	68,0,1232,.LM111-.LFBB9
 791               	.LM111:
 792 02ae 9091 0000 		lds r25,ledIndex
 793 02b2 E92F      		mov r30,r25
 794 02b4 F0E0      		ldi r31,lo8(0)
 795 02b6 E050      		subi r30,lo8(-(ledState))
 796 02b8 F040      		sbci r31,hi8(-(ledState))
 797 02ba 8081      		ld r24,Z
1236:main.c        **** 		incrementLEDIndex();
 798               		.stabn	68,0,1236,.LM112-.LFBB9
 799               	.LM112:
 800 02bc 9F5F      		subi r25,lo8(-(1))
 801 02be 9093 0000 		sts ledIndex,r25
 802 02c2 9330      		cpi r25,lo8(3)
 803 02c4 01F4      		brne .L68
 804 02c6 1092 0000 		sts ledIndex,__zero_reg__
 805 02ca 00C0      		rjmp .L68
 806               	.L54:
 807               	.LBE23:
 808               	.LBE21:
 809               	.LBE20:
1078:main.c        **** 					USIDR = 0xff;
 810               		.stabn	68,0,1078,.LM113-.LFBB9
 811               	.LM113:
 812 02cc 8FEF      		ldi r24,lo8(-1)
 813               	.L68:
 814 02ce 8FB9      		out 47-0x20,r24
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 42


1084:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
 815               		.stabn	68,0,1084,.LM114-.LFBB9
 816               	.LM114:
 817 02d0 B89A      		sbi 55-0x20,0
 818               	.L52:
 819               	.LBE19:
1087:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_BYTE;
 820               		.stabn	68,0,1087,.LM115-.LFBB9
 821               	.LM115:
 822 02d2 84E0      		ldi r24,lo8(4)
 823 02d4 8093 0000 		sts usi_i2c_state,r24
1089:main.c        **** 			USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(0);
 824               		.stabn	68,0,1089,.LM116-.LFBB9
 825               	.LM116:
 826 02d8 80E4      		ldi r24,lo8(64)
 827 02da 00C0      		rjmp .L69
 828               	.L74:
1093:main.c        **** 			byteNum++;
 829               		.stabn	68,0,1093,.LM117-.LFBB9
 830               	.LM117:
 831 02dc 9091 0000 		lds r25,byteNum
 832 02e0 9F5F      		subi r25,lo8(-(1))
 833 02e2 9093 0000 		sts byteNum,r25
1095:main.c        **** 			if(!usi_i2c_readFromSlave)
 834               		.stabn	68,0,1095,.LM118-.LFBB9
 835               	.LM118:
 836 02e6 8091 0000 		lds r24,usi_i2c_readFromSlave
 837 02ea 8823      		tst r24
 838 02ec 01F4      		brne .L59
1097:main.c        **** 				processReceivedByte(USIDR, byteNum);
 839               		.stabn	68,0,1097,.LM119-.LFBB9
 840               	.LM119:
 841 02ee 8FB1      		in r24,47-0x20
 842               	.LBB24:
 843               	.LBB25:
1174:main.c        ****   if(usi_i2c_requestedAddress == USI_I2C_MYEDIDADDRESS)
 844               		.stabn	68,0,1174,.LM120-.LFBB9
 845               	.LM120:
 846 02f0 2091 0000 		lds r18,usi_i2c_requestedAddress
 847 02f4 2035      		cpi r18,lo8(80)
 848 02f6 01F4      		brne .L60
1176:main.c        **** 	if(byteNum == 1)
 849               		.stabn	68,0,1176,.LM121-.LFBB9
 850               	.LM121:
 851 02f8 9130      		cpi r25,lo8(1)
 852 02fa 01F4      		brne .L61
1180:main.c        **** 		setEDIDIndex(receivedByte);
 853               		.stabn	68,0,1180,.LM122-.LFBB9
 854               	.LM122:
 855 02fc 8F77      		andi r24,lo8(127)
 856 02fe 8093 0000 		sts edidArrayIndex,r24
 857 0302 00C0      		rjmp .L62
 858               	.L61:
1185:main.c        **** 		edidArray[edidArrayIndex] = receivedByte;
 859               		.stabn	68,0,1185,.LM123-.LFBB9
 860               	.LM123:
 861 0304 9091 0000 		lds r25,edidArrayIndex
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 43


 862 0308 E92F      		mov r30,r25
 863 030a F0E0      		ldi r31,lo8(0)
 864 030c E050      		subi r30,lo8(-(edidArray))
 865 030e F040      		sbci r31,hi8(-(edidArray))
 866 0310 8083      		st Z,r24
1187:main.c        **** 		incrementEDIDIndex();
 867               		.stabn	68,0,1187,.LM124-.LFBB9
 868               	.LM124:
 869 0312 892F      		mov r24,r25
 870 0314 8F5F      		subi r24,lo8(-(1))
 871 0316 8093 0000 		sts edidArrayIndex,r24
 872 031a 8038      		cpi r24,lo8(-128)
 873 031c 01F4      		brne .L62
 874 031e 1092 0000 		sts edidArrayIndex,__zero_reg__
 875 0322 00C0      		rjmp .L62
 876               	.L60:
1192:main.c        ****   else if (usi_i2c_requestedAddress == USI_I2C_MYLEDADDRESS)
 877               		.stabn	68,0,1192,.LM125-.LFBB9
 878               	.LM125:
 879 0324 2036      		cpi r18,lo8(96)
 880 0326 01F4      		brne .L62
1195:main.c        **** 	ledsControlled = TRUE;
 881               		.stabn	68,0,1195,.LM126-.LFBB9
 882               	.LM126:
 883 0328 21E0      		ldi r18,lo8(1)
 884 032a 2093 0000 		sts ledsControlled,r18
1197:main.c        **** 	if(byteNum == 1)
 885               		.stabn	68,0,1197,.LM127-.LFBB9
 886               	.LM127:
 887 032e 9130      		cpi r25,lo8(1)
 888 0330 01F4      		brne .L63
1199:main.c        **** 		setLEDIndex(receivedByte);
 889               		.stabn	68,0,1199,.LM128-.LFBB9
 890               	.LM128:
 891 0332 63E0      		ldi r22,lo8(3)
 892 0334 00D0      		rcall __udivmodqi4
 893 0336 9093 0000 		sts ledIndex,r25
 894 033a 00C0      		rjmp .L62
 895               	.L63:
1203:main.c        **** 		ledState[ledIndex] = receivedByte;
 896               		.stabn	68,0,1203,.LM129-.LFBB9
 897               	.LM129:
 898 033c 9091 0000 		lds r25,ledIndex
 899 0340 E92F      		mov r30,r25
 900 0342 F0E0      		ldi r31,lo8(0)
 901 0344 E050      		subi r30,lo8(-(ledState))
 902 0346 F040      		sbci r31,hi8(-(ledState))
 903 0348 8083      		st Z,r24
1204:main.c        **** 		incrementLEDIndex();
 904               		.stabn	68,0,1204,.LM130-.LFBB9
 905               	.LM130:
 906 034a 892F      		mov r24,r25
 907 034c 8F5F      		subi r24,lo8(-(1))
 908 034e 8093 0000 		sts ledIndex,r24
 909 0352 8330      		cpi r24,lo8(3)
 910 0354 01F4      		brne .L62
 911 0356 1092 0000 		sts ledIndex,__zero_reg__
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 44


 912               	.L62:
 913               	.LBE25:
 914               	.LBE24:
1099:main.c        **** 				heartBlinkInternal = usi_i2c_receivedByte;
 915               		.stabn	68,0,1099,.LM131-.LFBB9
 916               	.LM131:
 917 035a 8091 0000 		lds r24,usi_i2c_receivedByte
 918 035e 8093 0000 		sts heartBlinkInternal,r24
1104:main.c        **** 				USIDR = 0x3f;
 919               		.stabn	68,0,1104,.LM132-.LFBB9
 920               	.LM132:
 921 0362 8FE3      		ldi r24,lo8(63)
 922 0364 8FB9      		out 47-0x20,r24
1105:main.c        **** 				setoutPORT(SDA_PIN, SDAPORT);
 923               		.stabn	68,0,1105,.LM133-.LFBB9
 924               	.LM133:
 925 0366 B89A      		sbi 55-0x20,0
 926 0368 00C0      		rjmp .L64
 927               	.L59:
1110:main.c        **** 				setinPORT(SDA_PIN, SDAPORT);
 928               		.stabn	68,0,1110,.LM134-.LFBB9
 929               	.LM134:
 930 036a B898      		cbi 55-0x20,0
1111:main.c        **** 				USIDR = 0xff;
 931               		.stabn	68,0,1111,.LM135-.LFBB9
 932               	.LM135:
 933 036c 8FEF      		ldi r24,lo8(-1)
 934 036e 8FB9      		out 47-0x20,r24
 935               	.L64:
1116:main.c        **** 			USI_I2C_OVERFLOW_RELEASE_SCL_AND_SET_COUNTER(14);
 936               		.stabn	68,0,1116,.LM136-.LFBB9
 937               	.LM136:
 938 0370 8EE4      		ldi r24,lo8(78)
 939 0372 8EB9      		out 46-0x20,r24
1118:main.c        **** 			usi_i2c_state = USI_STATE_AWAITING_ACK;
 940               		.stabn	68,0,1118,.LM137-.LFBB9
 941               	.LM137:
 942 0374 83E0      		ldi r24,lo8(3)
 943 0376 00C0      		rjmp .L70
 944               	.L42:
1123:main.c        **** 			usi_i2c_state = 0x77;
 945               		.stabn	68,0,1123,.LM138-.LFBB9
 946               	.LM138:
 947 0378 87E7      		ldi r24,lo8(119)
 948               	.L70:
 949 037a 8093 0000 		sts usi_i2c_state,r24
 950               	.L48:
 951               	.LBE18:
1130:main.c        **** 	if((usi_i2c_readFromSlave)
 952               		.stabn	68,0,1130,.LM139-.LFBB9
 953               	.LM139:
 954 037e 8091 0000 		lds r24,usi_i2c_readFromSlave
 955 0382 8823      		tst r24
 956 0384 01F0      		breq .L66
 957 0386 8091 0000 		lds r24,usi_i2c_state
 958 038a 8430      		cpi r24,lo8(4)
 959 038c 01F4      		brne .L66
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 45


 960 038e 8091 0000 		lds r24,usi_i2c_requestedAddress
 961 0392 8035      		cpi r24,lo8(80)
 962 0394 01F4      		brne .L66
1133:main.c        **** 		set_heartBlink(0);
 963               		.stabn	68,0,1133,.LM140-.LFBB9
 964               	.LM140:
 965 0396 80E0      		ldi r24,lo8(0)
 966 0398 00D0      		rcall set_heartBlink
 967               	.L66:
 968               	/* epilogue start */
1135:main.c        **** }
 969               		.stabn	68,0,1135,.LM141-.LFBB9
 970               	.LM141:
 971 039a FF91      		pop r31
 972 039c EF91      		pop r30
 973 039e BF91      		pop r27
 974 03a0 AF91      		pop r26
 975 03a2 9F91      		pop r25
 976 03a4 8F91      		pop r24
 977 03a6 7F91      		pop r23
 978 03a8 6F91      		pop r22
 979 03aa 5F91      		pop r21
 980 03ac 4F91      		pop r20
 981 03ae 3F91      		pop r19
 982 03b0 2F91      		pop r18
 983 03b2 0F90      		pop r0
 984 03b4 0FBE      		out __SREG__,r0
 985 03b6 0F90      		pop r0
 986 03b8 1F90      		pop __zero_reg__
 987 03ba 1895      		reti
 988               		.size	__vector_14, .-__vector_14
 989               		.stabs	"udrTemp:r(3,2)",64,0,1007,24
 990               		.stabn	192,0,0,.LBB18-.LFBB9
 991               		.stabs	"temp:r(3,2)",64,0,1217,24
 992               		.stabn	192,0,0,.LBB22-.LFBB9
 993               		.stabn	224,0,0,.LBE22-.LFBB9
 994               		.stabn	224,0,0,.LBE18-.LFBB9
 995               	.Lscope9:
 996               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 997               		.stabd	78,0,0
 998               	.global	header
 999               		.section	.progmem.data,"a",@progbits
 1000               		.type	header, @object
 1001               		.size	header, 32
 1002               	header:
 1003 0000 4C43 4472 		.string	"LCDreIDer51 2013-12-30 19:22:35"
 1003      6549 4465 
 1003      7235 3120 
 1003      3230 3133 
 1003      2D31 322D 
 1004               	.global	ledState
 1005               	.global	ledState
 1006               		.section .bss
 1007               		.type	ledState, @object
 1008               		.size	ledState, 3
 1009               	ledState:
 1010 0000 0000 00   		.skip 3,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 46


 1011               	.global	ledIndex
 1012               	.global	ledIndex
 1013               		.type	ledIndex, @object
 1014               		.size	ledIndex, 1
 1015               	ledIndex:
 1016 0003 00        		.skip 1,0
 1017               	.global	edidArray
 1018               		.data
 1019               		.type	edidArray, @object
 1020               		.size	edidArray, 128
 1021               	edidArray:
 1022 0000 00        		.byte	0
 1023 0001 FF        		.byte	-1
 1024 0002 FF        		.byte	-1
 1025 0003 FF        		.byte	-1
 1026 0004 FF        		.byte	-1
 1027 0005 FF        		.byte	-1
 1028 0006 FF        		.byte	-1
 1029 0007 00        		.byte	0
 1030 0008 34        		.byte	52
 1031 0009 A8        		.byte	-88
 1032 000a 51        		.byte	81
 1033 000b 01        		.byte	1
 1034 000c 00        		.byte	0
 1035 000d 00        		.byte	0
 1036 000e 00        		.byte	0
 1037 000f 00        		.byte	0
 1038 0010 00        		.byte	0
 1039 0011 17        		.byte	23
 1040 0012 01        		.byte	1
 1041 0013 03        		.byte	3
 1042 0014 80        		.byte	-128
 1043 0015 19        		.byte	25
 1044 0016 12        		.byte	18
 1045 0017 78        		.byte	120
 1046 0018 0A        		.byte	10
 1047 0019 AF        		.byte	-81
 1048 001a 40        		.byte	64
 1049 001b 95        		.byte	-107
 1050 001c 56        		.byte	86
 1051 001d 4A        		.byte	74
 1052 001e 8F        		.byte	-113
 1053 001f 25        		.byte	37
 1054 0020 20        		.byte	32
 1055 0021 50        		.byte	80
 1056 0022 54        		.byte	84
 1057 0023 00        		.byte	0
 1058 0024 00        		.byte	0
 1059 0025 00        		.byte	0
 1060 0026 01        		.byte	1
 1061 0027 01        		.byte	1
 1062 0028 01        		.byte	1
 1063 0029 01        		.byte	1
 1064 002a 01        		.byte	1
 1065 002b 01        		.byte	1
 1066 002c 01        		.byte	1
 1067 002d 01        		.byte	1
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 47


 1068 002e 01        		.byte	1
 1069 002f 01        		.byte	1
 1070 0030 01        		.byte	1
 1071 0031 01        		.byte	1
 1072 0032 01        		.byte	1
 1073 0033 01        		.byte	1
 1074 0034 01        		.byte	1
 1075 0035 01        		.byte	1
 1076 0036 10        		.byte	16
 1077 0037 27        		.byte	39
 1078 0038 78        		.byte	120
 1079 0039 E0        		.byte	-32
 1080 003a 50        		.byte	80
 1081 003b 1A        		.byte	26
 1082 003c 08        		.byte	8
 1083 003d 40        		.byte	64
 1084 003e 20        		.byte	32
 1085 003f 20        		.byte	32
 1086 0040 02        		.byte	2
 1087 0041 00        		.byte	0
 1088 0042 F5        		.byte	-11
 1089 0043 B8        		.byte	-72
 1090 0044 00        		.byte	0
 1091 0045 00        		.byte	0
 1092 0046 00        		.byte	0
 1093 0047 18        		.byte	24
 1094 0048 10        		.byte	16
 1095 0049 27        		.byte	39
 1096 004a 78        		.byte	120
 1097 004b F4        		.byte	-12
 1098 004c 50        		.byte	80
 1099 004d 1A        		.byte	26
 1100 004e 0A        		.byte	10
 1101 004f 40        		.byte	64
 1102 0050 20        		.byte	32
 1103 0051 20        		.byte	32
 1104 0052 22        		.byte	34
 1105 0053 00        		.byte	0
 1106 0054 F5        		.byte	-11
 1107 0055 B8        		.byte	-72
 1108 0056 00        		.byte	0
 1109 0057 00        		.byte	0
 1110 0058 00        		.byte	0
 1111 0059 00        		.byte	0
 1112 005a 00        		.byte	0
 1113 005b 00        		.byte	0
 1114 005c 00        		.byte	0
 1115 005d 10        		.byte	16
 1116 005e 00        		.byte	0
 1117 005f 00        		.byte	0
 1118 0060 00        		.byte	0
 1119 0061 00        		.byte	0
 1120 0062 00        		.byte	0
 1121 0063 00        		.byte	0
 1122 0064 00        		.byte	0
 1123 0065 00        		.byte	0
 1124 0066 00        		.byte	0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 48


 1125 0067 00        		.byte	0
 1126 0068 00        		.byte	0
 1127 0069 00        		.byte	0
 1128 006a 00        		.byte	0
 1129 006b 00        		.byte	0
 1130 006c 00        		.byte	0
 1131 006d 00        		.byte	0
 1132 006e 00        		.byte	0
 1133 006f FC        		.byte	-4
 1134 0070 00        		.byte	0
 1135 0071 6D        		.byte	109
 1136 0072 65        		.byte	101
 1137 0073 68        		.byte	104
 1138 0074 4C        		.byte	76
 1139 0075 54        		.byte	84
 1140 0076 44        		.byte	68
 1141 0077 31        		.byte	49
 1142 0078 32        		.byte	50
 1143 0079 31        		.byte	49
 1144 007a 4B        		.byte	75
 1145 007b 4D        		.byte	77
 1146 007c 37        		.byte	55
 1147 007d 4B        		.byte	75
 1148 007e 00        		.byte	0
 1149 007f 75        		.byte	117
 1150               	.global	edidArrayIndex
 1151               	.global	edidArrayIndex
 1152               		.section .bss
 1153               		.type	edidArrayIndex, @object
 1154               		.size	edidArrayIndex, 1
 1155               	edidArrayIndex:
 1156 0004 00        		.skip 1,0
 1157               	.global	usi_i2c_byteToTransmit
 1158               		.data
 1159               		.type	usi_i2c_byteToTransmit, @object
 1160               		.size	usi_i2c_byteToTransmit, 1
 1161               	usi_i2c_byteToTransmit:
 1162 0080 FF        		.byte	-1
 1163               	.global	usi_i2c_state
 1164               	.global	usi_i2c_state
 1165               		.section .bss
 1166               		.type	usi_i2c_state, @object
 1167               		.size	usi_i2c_state, 1
 1168               	usi_i2c_state:
 1169 0005 00        		.skip 1,0
 1170               	.global	usi_i2c_readFromSlave
 1171               	.global	usi_i2c_readFromSlave
 1172               		.type	usi_i2c_readFromSlave, @object
 1173               		.size	usi_i2c_readFromSlave, 1
 1174               	usi_i2c_readFromSlave:
 1175 0006 00        		.skip 1,0
 1176               	.global	usi_i2c_requestedAddres
 1177               	.global	usi_i2c_requestedAddres
 1178               		.type	usi_i2c_requestedAddres, @object
 1179               		.size	usi_i2c_requestedAddres, 1
 1180               	usi_i2c_requestedAddres:
 1181 0007 00        		.skip 1,0
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 49


 1182               	.global	usi_i2c_receivedByte
 1183               	.global	usi_i2c_receivedByte
 1184               		.type	usi_i2c_receivedByte, @object
 1185               		.size	usi_i2c_receivedByte, 1
 1186               	usi_i2c_receivedByte:
 1187 0008 00        		.skip 1,0
 1188               	.global	heartBlinkInternal
 1189               	.global	heartBlinkInternal
 1190               		.type	heartBlinkInternal, @object
 1191               		.size	heartBlinkInternal, 1
 1192               	heartBlinkInternal:
 1193 0009 00        		.skip 1,0
 1194               	.global	usi_i2c_requestedAddress
 1195               	.global	usi_i2c_requestedAddress
 1196               		.type	usi_i2c_requestedAddress, @object
 1197               		.size	usi_i2c_requestedAddress, 1
 1198               	usi_i2c_requestedAddress:
 1199 000a 00        		.skip 1,0
 1200               	.global	byteNum
 1201               	.global	byteNum
 1202               		.type	byteNum, @object
 1203               		.size	byteNum, 1
 1204               	byteNum:
 1205 000b 00        		.skip 1,0
 1206               	.global	ledsControlled
 1207               	.global	ledsControlled
 1208               		.type	ledsControlled, @object
 1209               		.size	ledsControlled, 1
 1210               	ledsControlled:
 1211 000c 00        		.skip 1,0
 1212               		.lcomm lastState.1732,3
 1213               		.data
 1214               		.type	theta.1693, @object
 1215               		.size	theta.1693, 2
 1216               	theta.1693:
 1217 0081 0200      		.word	2
 1218               		.lcomm delay.1692,1
 1219               		.comm ledHFM,12,1
 1220               		.stabs	"header:G(0,18)=ar(0,17);0;31;(3,2)",32,0,16,0
 1221               		.stabs	"ledState:G(0,19)=ar(0,17);0;2;(0,20)=B(3,2)",32,0,267,0
 1222               		.stabs	"ledIndex:G(3,2)",32,0,268,0
 1223               		.stabs	"edidArray:G(0,21)=ar(0,17);0;127;(3,2)",32,0,276,0
 1224               		.stabs	"edidArrayIndex:G(3,2)",32,0,754,0
 1225               		.stabs	"usi_i2c_byteToTransmit:G(3,2)",32,0,786,0
 1226               		.stabs	"usi_i2c_state:G(3,2)",32,0,787,0
 1227               		.stabs	"usi_i2c_readFromSlave:G(3,2)",32,0,788,0
 1228               		.stabs	"usi_i2c_requestedAddres:G(3,2)",32,0,789,0
 1229               		.stabs	"usi_i2c_receivedByte:G(3,2)",32,0,790,0
 1230               		.stabs	"heartBlinkInternal:G(3,2)",32,0,896,0
 1231               		.stabs	"usi_i2c_requestedAddress:G(3,2)",32,0,953,0
 1232               		.stabs	"byteNum:G(3,2)",32,0,955,0
 1233               		.stabs	"ledsControlled:G(3,2)",32,0,1137,0
 1234               		.stabs	"ledHFM:G(0,22)=ar(0,17);0;2;(8,2)",32,0,1276,0
 1235               		.text
 1236               		.stabs	"",100,0,0,.Letext0
 1237               	.Letext0:
GAS LISTING /var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s 			page 50


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:2      *ABS*:0000003f __SREG__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:3      *ABS*:0000003e __SP_H__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:4      *ABS*:0000003d __SP_L__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:6      *ABS*:00000001 __zero_reg__
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:105    .text:00000000 usi_i2c_awaitStart
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1168   .bss:00000005 usi_i2c_state
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:146    .text:00000016 usi_i2c_awaitStartSCL
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:180    .text:0000002a usi_i2c_slaveInit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:201    .text:0000002e __vector_13
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1192   .bss:00000009 heartBlinkInternal
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:261    .text:00000066 edid_checkSummer
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1021   .data:00000000 edidArray
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:304    .text:00000080 updateLEDs
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1009   .bss:00000000 ledState
                             .bss:0000000d lastState.1732
                            *COM*:0000000c ledHFM
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:413    .text:000000f0 updateLEDFader
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1212   .bss:00000010 delay.1692
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1216   .data:00000081 theta.1693
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:538    .text:00000194 main
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1210   .bss:0000000c ledsControlled
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:630    .text:000001e0 __vector_14
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1204   .bss:0000000b byteNum
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1174   .bss:00000006 usi_i2c_readFromSlave
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1198   .bss:0000000a usi_i2c_requestedAddress
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1155   .bss:00000004 edidArrayIndex
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1015   .bss:00000003 ledIndex
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1186   .bss:00000008 usi_i2c_receivedByte
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1002   .progmem.data:00000000 header
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1161   .data:00000080 usi_i2c_byteToTransmit
/var/folders/yG/yGnXnnFGGj4hKA71DL26EU+++TI/-Tmp-//cc5Vyz7g.s:1180   .bss:00000007 usi_i2c_requestedAddres

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
hfm_setPower
hfm_nextOutput
sineRaw8
hfm_setup
init_heartBeat
setHeartRate
heartBlink
heartUpdate
__udivmodqi4
set_heartBlink
